<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700&amp;family=Poppins:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
    // Define OpenAI class
    class OpenAI {
      constructor(config) {
        this.baseURL = config.baseURL || 'https://api.openai.com/v1';
        this.apiKey = config.apiKey;
        this.images = {
          generate: this.generateImage.bind(this)
        };
      }
      
      async generateImage(params) {
        const url = `${this.baseURL}/images/generations`;
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.apiKey}`
          },
          body: JSON.stringify(params)
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || 'Image generation failed');
        }
        
        return await response.json();
      }
    }
  </script>
    <style>
      :root {
        --primary-color: #00ffff; /* Cyan neon */
        --primary-light: #80ffff;
        --primary-dark: #00cccc;
        --primary-color-rgb: 0, 255, 255; /* RGB values for primary color */
        --secondary-color: #ff00ff; /* Magenta neon */
        --secondary-light: #ff80ff;
        --secondary-color-rgb: 255, 0, 255; /* RGB values for secondary color */
        --accent-color: #00ff00; /* Green neon */
        --accent-light: #80ff80;
        --accent-color-rgb: 0, 255, 0; /* RGB values for accent color */
        --text-color: #ffffff;
        --light-text: #a0a0a0;
        --background: #0f0f13;
        --light-bg: #1a1a24;
        --card-bg: #191922;
        --dark-bg: #050508;
        --border-color: #333340;
        --border-glow: 0 0 5px var(--primary-color);
        --shadow: 0 4px 10px rgba(0, 255, 255, 0.15);
        --hover-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        --radius: 8px;
        --transition: all 0.3s ease;
      }

      @keyframes neon-pulse {
        0% { box-shadow: 0 0 5px var(--primary-color), 0 0 10px var(--primary-color); }
        50% { box-shadow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color); }
        100% { box-shadow: 0 0 5px var(--primary-color), 0 0 10px var(--primary-color); }
      }

      @keyframes text-glow {
        0% { text-shadow: 0 0 5px var(--primary-light), 0 0 10px var(--primary-light); }
        50% { text-shadow: 0 0 10px var(--primary-light), 0 0 15px var(--primary-light); }
        100% { text-shadow: 0 0 5px var(--primary-light), 0 0 10px var(--primary-light); }
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      
      body, html {
        height: 100%;
        width: 100%;
        font-family: 'Poppins', sans-serif;
        background-color: var(--background);
        color: var(--text-color);
        line-height: 1.6;
        background-image: 
          radial-gradient(circle at 30% 20%, rgba(0, 255, 255, 0.05) 0%, transparent 25%),
          radial-gradient(circle at 70% 80%, rgba(255, 0, 255, 0.05) 0%, transparent 25%);
      }

      .header {
        background-color: var(--dark-bg);
        color: var(--text-color);
        padding: 1rem 0;
        text-align: center;
        border-bottom: 2px solid var(--border-color);
        position: relative;
      }

      .header::after {
        content: "";
        position: absolute;
        bottom: -2px;
        left: 0;
        width: 100%;
        height: 2px;
        background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        box-shadow: 0 0 10px var(--primary-color);
      }

      .header-content {
        display: flex;
        align-items: center;
        justify-content: center;
        max-width: 1200px;
        margin: 0 auto;
      }

      .logo {
        font-family: 'Orbitron', sans-serif;
        font-size: 1.8rem;
        font-weight: 700;
        margin-left: 10px;
        color: var(--primary-color);
        animation: text-glow 2s infinite;
        letter-spacing: 1px;
        text-transform: uppercase;
      }

      .logo-icon {
        font-size: 2rem;
        margin-right: 10px;
        color: var(--accent-color);
      }

      .container {
        width: 100%;
        max-width: 1000px;
        margin: 2rem auto;
        padding: 2.5rem;
        background-color: var(--light-bg);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        border: 1px solid var(--border-color);
        position: relative;
        overflow: hidden;
      }

      .container::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
      }
      
      .title {
        text-align: center;
        margin-bottom: 2.5rem;
        color: var(--primary-color);
        font-weight: 600;
        font-size: 2.2rem;
        font-family: 'Orbitron', sans-serif;
        letter-spacing: 2px;
        text-shadow: 0 0 10px var(--primary-color);
      }
      
      .form-section {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 2rem;
        margin-bottom: 2rem;
      }
      
      .form-group {
        margin-bottom: 1.5rem;
        background: var(--card-bg);
        padding: 1.5rem;
        border-radius: var(--radius);
        transition: var(--transition);
        border: 1px solid var(--border-color);
        position: relative;
        overflow: hidden;
      }

      .form-group::after {
        content: "";
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 2px;
        background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
        opacity: 0;
        transition: var(--transition);
      }

      .form-group:hover {
        box-shadow: var(--hover-shadow);
      }

      .form-group:hover::after {
        opacity: 1;
      }
      
      label {
        display: block;
        margin-bottom: 0.75rem;
        font-weight: 500;
        color: var(--primary-color);
        font-family: 'Orbitron', sans-serif;
        letter-spacing: 1px;
      }
      
      textarea, select {
        width: 100%;
        padding: 1rem;
        background-color: var(--dark-bg);
        color: var(--text-color);
        border: 1px solid var(--border-color);
        border-radius: var(--radius);
        font-family: 'Poppins', sans-serif;
        transition: var(--transition);
        font-size: 1rem;
      }

      textarea:focus, select:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 5px var(--primary-color);
      }
      
      .button-group {
        margin-top: 1rem;
        display: flex;
        gap: 0.5rem;
      }
      
      button {
        background-color: var(--dark-bg);
        color: var(--primary-color);
        border: 1px solid var(--primary-color);
        padding: 0.75rem 1.5rem;
        border-radius: var(--radius);
        cursor: pointer;
        font-weight: 500;
        font-size: 0.95rem;
        transition: var(--transition);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        position: relative;
        overflow: hidden;
        font-family: 'Orbitron', sans-serif;
        letter-spacing: 0.5px;
      }

      button::after {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        transition: 0.5s;
      }

      button:hover {
        box-shadow: 0 0 10px var(--primary-color);
        transform: translateY(-2px);
      }

      button:hover::after {
        left: 100%;
      }

      button:active {
        transform: translateY(0);
      }
      
      #randomPromptBtn {
        color: var(--accent-color);
        border-color: var(--accent-color);
      }
      
      #randomPromptBtn:hover {
        box-shadow: 0 0 10px var(--accent-color);
      }
      
      #enhancePromptBtn {
        color: var(--secondary-color);
        border-color: var(--secondary-color);
      }
      
      #enhancePromptBtn:hover {
        box-shadow: 0 0 10px var(--secondary-color);
      }
      
      #clearPromptBtn {
        color: #ff3366;
        border-color: #ff3366;
      }
      
      #clearPromptBtn:hover {
        box-shadow: 0 0 10px #ff3366;
      }
      
      #generateBtn {
        width: 100%;
        padding: 1.2rem;
        font-size: 1.1rem;
        margin-top: 1rem;
        background: var(--dark-bg);
        color: var(--text-color);
        border: 1px solid var(--primary-color);
        position: relative;
        overflow: hidden;
        z-index: 1;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-family: 'Orbitron', sans-serif;
        font-weight: 600;
      }

      #generateBtn::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(45deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        opacity: 0;
        transition: 0.5s;
        z-index: -1;
      }

      #generateBtn:hover {
        color: var(--dark-bg);
        box-shadow: 0 0 15px var(--primary-color);
      }

      #generateBtn:hover::before {
        opacity: 1;
      }

      #generateBtn i {
        margin-right: 10px;
      }
      
      /* Keyboard Shortcuts Help Styles */
      .shortcuts-help {
        position: fixed;
        top: 20px;
        right: 60px;
        background-color: var(--dark-bg);
        border: 1px solid var(--primary-color);
        border-radius: var(--radius);
        padding: 15px;
        box-shadow: 0 0 15px rgba(var(--primary-color-rgb), 0.5);
        z-index: 1000;
        display: none;
        max-width: 300px;
      }
      
      .shortcuts-help-content h3 {
        margin-top: 0;
        color: var(--primary-color);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 8px;
        margin-bottom: 10px;
      }
      
      .shortcuts-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      
      .shortcuts-list li {
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      
      kbd {
        background-color: var(--light-bg);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
        color: var(--text-color);
        display: inline-block;
        font-family: monospace;
        font-size: 0.9em;
        font-weight: bold;
        line-height: 1;
        padding: 3px 6px;
        margin: 0 2px;
      }
      
      .loading {
        display: none;
        text-align: center;
        margin: 2rem 0;
        padding: 2rem;
        border-radius: var(--radius);
        background-color: var(--card-bg);
        border: 1px solid var(--border-color);
        animation: neon-pulse 2s infinite;
      }
      
      .cancel-btn {
        margin-top: 1rem;
        color: #ff3366;
        border-color: #ff3366;
      }
      
      .cancel-btn:hover {
        box-shadow: 0 0 10px #ff3366;
      }

      .loading-spinner {
        display: inline-block;
        width: 3rem;
        height: 3rem;
        border: 4px solid rgba(0, 255, 255, 0.1);
        border-radius: 50%;
        border-top-color: var(--primary-color);
        animation: spin 1s ease infinite;
        margin-bottom: 1rem;
        box-shadow: 0 0 10px var(--primary-color);
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      
      .result {
        margin-top: 2.5rem;
      }

      .image-gallery {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 2rem;
        margin-top: 2rem;
      }
      
      .generated-image {
        width: 100%;
        height: auto;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        transition: var(--transition);
        border: 2px solid var(--border-color);
      }

      .generated-image:hover {
        transform: scale(1.03);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
      }
      
      .image-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 1rem;
        background: var(--card-bg);
        border-radius: var(--radius);
        border: 1px solid var(--border-color);
        transition: var(--transition);
        position: relative;
        overflow: hidden;
      }

      .image-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 2px;
        background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
        box-shadow: 0 0 10px var(--primary-color);
      }

      .image-container:hover {
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
      }

      .download-link {
        margin-top: 1rem;
        padding: 0.8rem 1.2rem;
        background-color: transparent;
        color: var(--primary-color);
        text-decoration: none;
        border-radius: var(--radius);
        font-weight: 500;
        transition: var(--transition);
        display: flex;
        align-items: center;
        gap: 0.5rem;
        border: 1px solid var(--primary-color);
        font-family: 'Orbitron', sans-serif;
        letter-spacing: 0.5px;
      }

      .download-link:hover {
        box-shadow: 0 0 10px var(--primary-color);
        transform: translateY(-2px);
      }
      
      .error {
        color: #ff3366;
        text-align: center;
        margin-top: 1rem;
        padding: 1rem;
        background-color: rgba(255, 51, 102, 0.1);
        border-radius: var(--radius);
        font-weight: 500;
        display: none;
        border: 1px solid rgba(255, 51, 102, 0.3);
      }

      .footer {
        text-align: center;
        padding: 2rem 0;
        margin-top: 2rem;
        border-top: 1px solid var(--border-color);
        color: var(--light-text);
        font-size: 0.9rem;
        background-color: var(--dark-bg);
        position: relative;
      }

      .footer::before {
        content: "";
        position: absolute;
        top: -2px;
        left: 0;
        width: 100%;
        height: 2px;
        background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        opacity: 0.5;
      }

      /* Custom scrollbar */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }

      ::-webkit-scrollbar-track {
        background: var(--dark-bg);
      }

      ::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: var(--primary-dark);
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .container {
          padding: 1.5rem;
          margin-top: 1rem;
          margin-bottom: 1rem;
        }
        
        .form-section {
          grid-template-columns: 1fr;
        }
        
        .button-group {
          flex-direction: column;
        }

        .title {
          font-size: 1.8rem;
        }
      }

      /* Background grid effect */
      .grid-background {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
          linear-gradient(rgba(15, 15, 19, 0.9) 1px, transparent 1px),
          linear-gradient(90deg, rgba(15, 15, 19, 0.9) 1px, transparent 1px);
        background-size: 40px 40px;
        pointer-events: none;
        z-index: -1;
      }
    /* Additional Styles for New Features */
    .generation-info {
      margin-top: 1rem;
      padding: 1rem;
      background-color: var(--card-bg);
      border-radius: var(--radius);
      border: 1px solid var(--border-color);
    }
    
    .prompt-display {
      margin: 0.5rem 0;
      padding: 0.5rem;
      background-color: var(--dark-bg);
      border-radius: var(--radius);
      font-size: 0.9rem;
      color: var(--light-text);
      word-break: break-word;
    }
    
    .meta-info {
      font-size: 0.8rem;
      color: var(--primary-color);
      margin-bottom: 0.5rem;
    }
    
    .button-container {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
    }
    
    /* Image upscale dialog */
    .dialog-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    
    .dialog-content {
      background-color: var(--light-bg);
      padding: 2rem;
      border-radius: var(--radius);
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      border: 1px solid var(--primary-color);
      box-shadow: 0 0 20px var(--primary-color);
      animation: neon-pulse 2s infinite;
    }
    
    .dialog-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5rem;
    }
    
    .close-dialog {
      background: none;
      border: none;
      color: var(--primary-color);
      font-size: 1.5rem;
      cursor: pointer;
    }
    
    /* Dark mode toggle */
    .theme-toggle {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      color: var(--text-color);
      font-size: 1.2rem;
      cursor: pointer;
      z-index: 100;
    }
    
    /* Light theme variables */
    .light-theme {
      --primary-color: #0088ff;
      --primary-light: #66b5ff;
      --primary-dark: #0066cc;
      --secondary-color: #ff00aa;
      --secondary-light: #ff66cc;
      --accent-color: #00cc66;
      --accent-light: #66e0a3;
      --text-color: #333333;
      --light-text: #666666;
      --background: #f5f5f7;
      --light-bg: #ffffff;
      --card-bg: #f0f0f5;
      --dark-bg: #e0e0e5;
      --border-color: #ccccdd;
    }
    
    /* Settings toggle styles */
    .settings-bar {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 1.5rem;
      padding: 0.5rem;
      background-color: var(--card-bg);
      border-radius: var(--radius);
      border: 1px solid var(--border-color);
    }
    
    .settings-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: transform 0.3s ease;
    }
    
    .toggle-animation {
      animation: bounce-scale 0.7s ease;
    }
    
    @keyframes bounce-scale {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      75% { transform: scale(0.95); }
      100% { transform: scale(1); }
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 52px;
      height: 26px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--dark-bg);
      transition: all 0.4s ease;
      border-radius: 34px;
      border: 1px solid var(--border-color);
      overflow: hidden;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 4px;
      bottom: 3px;
      background-color: var(--primary-color);
      transition: all 0.4s ease;
      border-radius: 50%;
      box-shadow: 0 0 5px var(--primary-color);
      animation: pulse-light 1.5s infinite;
      z-index: 1;
    }
    
    @keyframes pulse-light {
      0% { box-shadow: 0 0 5px var(--primary-color); }
      50% { box-shadow: 0 0 12px var(--primary-color); }
      100% { box-shadow: 0 0 5px var(--primary-color); }
    }
    
    .toggle-slider:after {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(var(--primary-color-rgb), 0.1) 50%, 
        transparent 100%);
      left: -100%;
      transition: .7s;
    }

    input:checked + .toggle-slider {
      background-color: rgba(var(--primary-color-rgb), 0.15);
      border-color: var(--primary-color);
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
      background-color: var(--primary-color);
    }
    
    input:not(:checked) + .toggle-slider {
      background-color: var(--dark-bg);
      border-color: var(--border-color);
    }
    
    input:not(:checked) + .toggle-slider:before {
      background-color: var(--light-text);
      box-shadow: 0 0 5px rgba(160, 160, 160, 0.5);
    }
    
    input:checked + .toggle-slider:after {
      animation: slide-shine 2s infinite;
    }
    
    @keyframes slide-shine {
      0% { left: -100%; }
      40% { left: 100%; }
      100% { left: 100%; }
    }
    
    .toggle-label {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      color: var(--primary-color);
      letter-spacing: 0.5px;
    }
    
    .pulse-icon {
      animation: pulse-fade 1.5s infinite;
      display: inline-block;
    }
    
    @keyframes pulse-fade {
      0% { opacity: 0.7; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
      100% { opacity: 0.7; transform: scale(1); }
    }
    
    /* Search container styles */
    .search-container {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      align-items: center;
    }
    
    .search-input {
      flex: 1;
      padding: 0.75rem 1rem;
      background-color: var(--dark-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      font-family: 'Poppins', sans-serif;
      transition: var(--transition);
    }
    
    .search-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 5px var(--primary-color);
    }
    
    .search-btn {
      padding: 0.75rem 1rem;
      background-color: var(--dark-bg);
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
      border-radius: var(--radius);
      cursor: pointer;
      transition: var(--transition);
    }
    
    .search-btn:hover {
      box-shadow: 0 0 10px var(--primary-color);
    }
    
    .clear-btn {
      padding: 0.75rem 1rem;
      background-color: var(--dark-bg);
      color: #ff3366;
      border: 1px solid #ff3366;
      border-radius: var(--radius);
      cursor: pointer;
      transition: var(--transition);
    }
    
    .clear-btn:hover {
      box-shadow: 0 0 10px #ff3366;
    }
    
    /* Password dialog styles */
    .password-input-container {
      margin-top: 1rem;
    }
    
    .password-input {
      width: 100%;
      padding: 1rem;
      background-color: var(--dark-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      font-family: 'Poppins', sans-serif;
      transition: var(--transition);
      font-size: 1rem;
    }
    
    .password-error {
      color: #ff3366;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      display: none;
    }
    
    .download-source-btn {
      margin-top: 1rem;
      background: transparent;
      color: var(--accent-color);
      border-color: var(--accent-color);
      padding: 0.5rem 1.2rem;
      font-size: 0.9rem;
    }
    
    .download-source-btn:hover {
      box-shadow: 0 0 10px var(--accent-color);
    }
    
    .download-format-btn {
      margin-top: 0.5rem;
      background: transparent;
      color: var(--accent-color);
      border-color: var(--accent-color);
      padding: 1rem 1.2rem;
      font-size: 0.9rem;
      border-radius: var(--radius);
      cursor: pointer;
      transition: var(--transition);
      text-align: left;
      display: flex;
      flex-direction: column;
      width: 100%;
    }
    
    .download-format-btn:hover {
      box-shadow: 0 0 15px var(--accent-color);
      transform: translateY(-2px);
    }
    
    .filter-btn {
      background-color: var(--dark-bg);
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
      padding: 0.75rem 1.5rem;
      border-radius: var(--radius);
      cursor: pointer;
      font-weight: 500;
      font-size: 0.95rem;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }
    
    .filter-btn:hover {
      box-shadow: 0 0 10px var(--primary-color);
      transform: translateY(-2px);
    }
    
    .filter-btn.active {
      background-color: rgba(var(--primary-color-rgb), 0.2);
      box-shadow: 0 0 10px var(--primary-color);
    }
    
    /* Crop & Resize Styles */
    .slider {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 5px;
      background: var(--dark-bg);
      outline: none;
      margin: 10px 0;
    }
    
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary-color);
      cursor: pointer;
      box-shadow: 0 0 5px var(--primary-color);
    }
    
    .slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary-color);
      cursor: pointer;
      box-shadow: 0 0 5px var(--primary-color);
      border: none;
    }
    
    .aspect-btn {
      background-color: var(--dark-bg);
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
      padding: 0.5rem 1rem;
      border-radius: var(--radius);
      cursor: pointer;
      transition: var(--transition);
    }
    
    .aspect-btn:hover {
      box-shadow: 0 0 8px var(--primary-color);
    }
    
    .aspect-btn.active {
      background-color: rgba(var(--primary-color-rgb), 0.2);
      box-shadow: 0 0 10px var(--primary-color);
    }
    
    .tab-btn {
      background-color: var(--dark-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-bottom: none;
      padding: 0.7rem 1.2rem;
      border-radius: var(--radius) var(--radius) 0 0;
      cursor: pointer;
      transition: var(--transition);
    }
    
    .tab-btn:hover {
      background-color: var(--light-bg);
    }
    
    .tab-btn.active {
      background-color: var(--light-bg);
      color: var(--primary-color);
      border-color: var(--primary-color);
    }
    
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 1rem;
    }
    
    .tab-content {
      padding: 1rem;
      background-color: var(--light-bg);
      border-radius: 0 var(--radius) var(--radius) var(--radius);
    }
    
    .curve-channel-btn {
      background-color: var(--dark-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      padding: 0.5rem 1rem;
      border-radius: var(--radius);
      cursor: pointer;
      transition: var(--transition);
    }
    
    .curve-channel-btn:hover {
      background-color: var(--light-bg);
    }
    
    .curve-channel-btn.active {
      background-color: rgba(var(--primary-color-rgb), 0.2);
      color: var(--primary-color);
      border-color: var(--primary-color);
    }
    </style>
  <script src="https://lib.yourware.so/yourware-lib.umd.js" id="yourware-lib"></script></head>
  <body>
    <div class="grid-background"></div>
    
    <button id="themeToggle" class="theme-toggle" title="Toggle Theme (Shift+T)" style="position: relative;">
      <i class="fas fa-moon"></i>
    <span class="shortcut-indicator" style="font-size: 0.7rem; opacity: 0.7; margin-left: 5px; display: none; position: absolute; right: 0px; top: 100%; background-color: var(--dark-bg); padding: 3px; border-radius: 3px;"><kbd>Shift+T</kbd></span></button>
    
    <div id="shortcuts-help" class="shortcuts-help">
      <div class="shortcuts-help-content">
        <h3><i class="fas fa-keyboard"></i> Keyboard Shortcuts</h3>
        <ul class="shortcuts-list">
          <li><kbd>Ctrl</kbd> + <kbd>Enter</kbd> Generate Images</li>
          <li><kbd>Shift</kbd> + <kbd>R</kbd> Random Prompt</li>
          <li><kbd>Shift</kbd> + <kbd>E</kbd> Enhance Prompt</li>
          <li><kbd>Shift</kbd> + <kbd>C</kbd> Clear Prompt</li>
          <li><kbd>Shift</kbd> + <kbd>T</kbd> Toggle Theme</li>
          <li><kbd>?</kbd> Toggle Help</li>
        </ul>
      </div>
    </div>
    
    <header class="header">
      <div class="header-content">
        <i class="fas fa-paint-brush logo-icon"></i>
        <div class="logo">NeonAI Generator</div>
      </div>
    </header>

    <div class="container">
      <h1 class="title">Create Stunning AI Images</h1>
      
      <div class="settings-bar">
        <div class="settings-toggle">
          <label class="toggle-switch" title="Toggle history tracking on/off">
            <input type="checkbox" id="historyToggle" checked="">
            <span class="toggle-slider"></span>
          </label>
          <span class="toggle-label" style="color: var(--light-text);"><i class="fas fa-history pulse-icon" style="color: var(--light-text); animation: auto ease 0s 1 normal none running none; opacity: 0.7;"></i> History Tracking</span>
        </div>
      </div>
      
      <div class="form-group">
        <label for="prompt"><i class="fas fa-lightbulb"></i> Image Prompt:</label>
        <textarea id="prompt" rows="4" placeholder="Describe the image you want to generate...">A cyberpunk city at night with neon lights and holographic advertisements</textarea>
        <div class="button-group">
          <button id="randomPromptBtn" type="button" title="Random Prompt (Shift+R)"><i class="fas fa-random"></i> Random Prompt<span class="shortcut-indicator" style="font-size: 0.7rem; opacity: 0.7; margin-left: 5px; display: none;"><kbd>Shift+R</kbd></span></button>
          <button id="superEnhancePromptBtn" type="button" title="Super-Enhance with high detail"><i class="fas fa-wand-magic-sparkles"></i> Super-Enhance</button>
          <button id="clearPromptBtn" type="button" title="Clear Prompt (Shift+C)"><i class="fas fa-trash-alt"></i> Clear<span class="shortcut-indicator" style="font-size: 0.7rem; opacity: 0.7; margin-left: 5px; display: none;"><kbd>Shift+C</kbd></span></button>
        </div>
      </div>
      
      <div class="form-section">
        <div class="form-group">
          <label for="model"><i class="fas fa-robot"></i> AI Model:</label>
          <select id="model">
            <option value="Provider-5/flux-pro">Provider-5/flux-pro</option>
            <option value="Provider-3/flux-1.1-ultra">Provider-3/flux-1.1-ultra</option>
            <option value="Provider-5/flux-schnell">Provider-5/flux-schnell</option>
          </select>
          <div style="margin-top: 1rem; display: flex; align-items: center;">
            <label class="toggle-switch" title="Generate images with all models">
              <input type="checkbox" id="allModelsToggle">
              <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label" style="margin-left: 0.5rem;"><i class="fas fa-layer-group"></i> Use All Models</span>
          </div>
        </div>
        
        <div class="form-group">
          <label for="size"><i class="fas fa-expand"></i> Image Size:</label>
          <select id="size">
            <option value="1024x1024">1024x1024</option>
            <option value="1536x1536">1536x1536</option>
            <option value="1792x1024">1792x1024 (Widescreen)</option>
            <option value="1024x1792">1024x1792 (Portrait)</option>
            <option value="512x512">512x512</option>
            <option value="256x256">256x256</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="imageCount"><i class="fas fa-images"></i> Number of Images:</label>
          <select id="imageCount">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="style"><i class="fas fa-palette"></i> Style Preset:</label>
          <select id="style">
            <option value="none">None</option>
            <option value="cyberpunk">Cyberpunk</option>
            <option value="synthwave">Synthwave</option>
            <option value="vaporwave">Vaporwave</option>
            <option value="futuristic">Futuristic</option>
            <option value="dystopian">Dystopian</option>
            <option value="digital-art">Digital Art</option>
          </select>
        </div>
      </div>
      
      <button id="generateBtn" title="Generate Images (Ctrl+Enter)"><i class="fas fa-bolt"></i> Generate Images<span class="shortcut-indicator" style="font-size: 0.7rem; opacity: 0.7; margin-left: 5px; display: none;"><kbd>Ctrl+Enter</kbd></span></button>
      
      <div id="loading" class="loading" style="display: none;">
          <div class="loading-spinner"></div>
          <p>Cancelling generation...</p>
        </div>
      
      <div id="error" class="error" style="display: block; background-color: rgba(255, 193, 7, 0.1); color: rgb(255, 193, 7); border: 1px solid rgba(255, 193, 7, 0.3);">Image generation was cancelled</div>
      <div id="result" class="result"><div class="model-section" style="margin-bottom: 3rem;"><h3 style="color: var(--primary-color); margin-bottom: 1rem; font-family: Orbitron, sans-serif;">Model: Provider-5/flux-pro</h3><div class="image-gallery"></div></div></div>
      

      <div id="savedImagesSection" style="margin-top: 3rem; display: none;">
        <h2 class="title" style="font-size: 1.8rem; margin-bottom: 1.5rem;">Your Saved Images</h2>
        <div id="savedImagesGallery" class="image-gallery"></div>
      </div>
      
      <div id="historySection" style="margin-top: 3rem; display: none;">
        <h2 class="title" style="font-size: 1.8rem; margin-bottom: 1.5rem;">Image History</h2>
        <div class="search-container">
          <input type="text" id="historySearch" placeholder="Search in history by prompt keywords..." class="search-input">
          <button id="searchHistoryBtn" type="button" class="search-btn"><i class="fas fa-search"></i></button>
          <button id="clearHistoryBtn" type="button" class="clear-btn"><i class="fas fa-trash"></i> Clear History</button>
        </div>
        <div id="historyGallery" class="image-gallery"></div>
      </div>
    </div>

    <footer class="footer">
      <p>© 2023 NeonAI Generator. Craft cutting-edge AI-generated images with futuristic style.</p>
      <div class="button-container" style="margin-top: 1rem;">
        <button id="downloadSourceBtn" class="download-source-btn" style="display: inline-block;"><i class="fas fa-code"></i> Download Source Code</button>
        <button id="downloadApkBtn" class="download-source-btn" style="color: var(--secondary-color); border-color: var(--secondary-color); display: inline-block;"><i class="fas fa-android"></i> Download APK</button>
      </div>
    </footer>
    
    <!-- Password Dialog -->
    <div id="passwordDialog" class="dialog-overlay" style="display: none;">
      <div class="dialog-content">
        <div class="dialog-header">
          <h3>Enter Password</h3>
          <button class="close-dialog" id="closePasswordDialog">×</button>
        </div>
        <p>Please enter the password to download:</p>
        <div class="password-input-container">
          <input type="password" id="passwordInput" placeholder="Enter password" class="password-input">
          <div id="passwordError" class="password-error" style="display: none;"></div>
        </div>
        <div id="downloadOptions">
          <button id="submitPasswordBtn" class="download-link" style="width: 100%; margin-top: 1.5rem;"><i class="fas fa-download"></i> Download Source Code</button>
        </div>
      </div>
    </div>
    
    <!-- APK Download Dialog -->
    <div id="apkPasswordDialog" class="dialog-overlay" style="display: flex;">
      <div class="dialog-content">
        <div class="dialog-header">
          <h3>Enter Password</h3>
          <button class="close-dialog" id="closeApkPasswordDialog">×</button>
        </div>
        <p>Please enter the password to download the APK:</p>
        <div class="password-input-container">
          <input type="password" id="apkPasswordInput" placeholder="Enter password" class="password-input">
          <div id="apkPasswordError" class="password-error" style="display: none;"></div>
        </div>
        <button id="downloadApkBtn" class="download-link" style="width: 100%; margin-top: 1.5rem; color: var(--secondary-color); border-color: var(--secondary-color);" disabled=""><i class="fas fa-spinner fa-spin"></i> Preparing APK...</button>
      </div>
    </div>
    
    <!-- Format Selection Dialog -->
    <div id="formatDialog" class="dialog-overlay">
      <div class="dialog-content" style="max-width: 400px;">
        <div class="dialog-header">
          <h3>Choose Download Format</h3>
          <button class="close-dialog" id="closeFormatDialog">×</button>
        </div>
        <p>Select a format to download your image:</p>
        <div class="format-options" style="margin-top: 1.5rem; display: flex; flex-direction: column; gap: 1rem;">
          <button class="download-format-btn" data-format="png">
            <i class="fas fa-file-image"></i> PNG Format
            <span style="font-size: 0.8rem; display: block; margin-top: 0.3rem; color: var(--light-text);">Best quality, larger file size</span>
          </button>
          <button class="download-format-btn" data-format="jpeg">
            <i class="fas fa-file-image"></i> JPEG Format
            <span style="font-size: 0.8rem; display: block; margin-top: 0.3rem; color: var(--light-text);">Good quality, smaller file size</span>
          </button>
          <button class="download-format-btn" data-format="webp">
            <i class="fas fa-file-image"></i> WebP Format
            <span style="font-size: 0.8rem; display: block; margin-top: 0.3rem; color: var(--light-text);">Modern format, best compression</span>
          </button>
        </div>
      </div>
    </div>
    
    <!-- Image Filters Dialog -->
    <div id="filterDialog" class="dialog-overlay">
      <div class="dialog-content" style="max-width: 700px;">
        <div class="dialog-header">
          <h3>Apply Image Filters</h3>
          <button class="close-dialog" id="closeFilterDialog">×</button>
        </div>
        <div style="display: flex; flex-direction: column; gap: 1.5rem;">
          <div style="display: flex; gap: 2rem; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 300px;">
              <h4>Original Image</h4>
              <img id="filterOriginalImage" src="" alt="Original image" style="width: 100%; border-radius: var(--radius); margin: 1rem 0;">
            </div>
            <div style="flex: 1; min-width: 300px;">
              <h4>Preview with Filter</h4>
              <img id="filterPreviewImage" src="" alt="Preview with filter" style="width: 100%; border-radius: var(--radius); margin: 1rem 0;">
            </div>
          </div>
          
          <div class="filter-options" style="display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center;">
            <button class="filter-btn" data-filter="none">Original</button>
            <button class="filter-btn" data-filter="grayscale">Grayscale</button>
            <button class="filter-btn" data-filter="sepia">Sepia</button>
            <button class="filter-btn" data-filter="invert">Invert</button>
            <button class="filter-btn" data-filter="saturate">Saturate</button>
            <button class="filter-btn" data-filter="brightness">Brighten</button>
            <button class="filter-btn" data-filter="contrast">Contrast</button>
            <button class="filter-btn" data-filter="blur">Blur</button>
          </div>
          
          <div style="display: flex; gap: 1rem;">
            <button id="applyFilterBtn" class="download-link" style="flex: 1; margin-top: 1rem;">
              <i class="fas fa-check"></i> Apply Filter &amp; Download
            </button>
            <button id="keyboardShortcutsBtn" class="download-link" style="margin-top: 1rem; white-space: nowrap;" title="View Keyboard Shortcuts">
              <i class="fas fa-keyboard"></i> Shortcuts
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Crop & Resize Dialog -->
    <div id="cropDialog" class="dialog-overlay">
      <div class="dialog-content" style="max-width: 800px;">
        <div class="dialog-header">
          <h3>Crop &amp; Resize Image</h3>
          <button class="close-dialog" id="closeCropDialog">×</button>
        </div>
        <div style="display: flex; flex-direction: column; gap: 1.5rem;">
          <div class="crop-container" style="position: relative; overflow: hidden; margin: 0 auto; max-width: 100%; max-height: 60vh;">
            <canvas id="cropCanvas" style="display: block; max-width: 100%;"></canvas>
            <div id="cropOverlay" style="position: absolute; border: 2px dashed #fff; box-shadow: 0 0 0 2000px rgba(0, 0, 0, 0.5); cursor: move;"></div>
            <div id="resizeHandle" style="position: absolute; width: 10px; height: 10px; background: var(--primary-color); border-radius: 50%; bottom: -5px; right: -5px; cursor: nwse-resize;"></div>
          </div>
          
          <div style="display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;">
            <div style="flex: 1;">
              <h4>Aspect Ratio</h4>
              <div class="aspect-ratio-options" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                <button class="aspect-btn" data-ratio="free">Free</button>
                <button class="aspect-btn" data-ratio="1:1">1:1</button>
                <button class="aspect-btn" data-ratio="4:3">4:3</button>
                <button class="aspect-btn" data-ratio="16:9">16:9</button>
                <button class="aspect-btn" data-ratio="3:2">3:2</button>
              </div>
            </div>
            
            <div style="flex: 1;">
              <h4>Output Size</h4>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="number" id="cropWidth" placeholder="Width" style="width: 80px;" min="50" max="4000">
                <span>×</span>
                <input type="number" id="cropHeight" placeholder="Height" style="width: 80px;" min="50" max="4000">
              </div>
              <label style="display: block; margin-top: 0.5rem;">
                <input type="checkbox" id="maintainAspectRatio" checked="">
                Maintain aspect ratio
              </label>
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem;">
            <button id="applyCropBtn" class="download-link" style="flex: 1;">
              <i class="fas fa-crop"></i> Apply &amp; Download
            </button>
            <button id="resetCropBtn" class="download-link" style="flex: 1;">
              <i class="fas fa-undo"></i> Reset Crop
            </button>
          </div>
        </div>
      </div>
    </div>
    

    

    
    <script>
      // Setup event listeners after the page loads
      document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('generateBtn').addEventListener('click', generateImage);
        document.getElementById('randomPromptBtn').addEventListener('click', generateRandomPrompt);
        document.getElementById('superEnhancePromptBtn').addEventListener('click', superEnhancePrompt);
        document.getElementById('clearPromptBtn').addEventListener('click', clearPrompt);
        document.getElementById('cancelGenerationBtn').addEventListener('click', cancelGeneration);
        document.getElementById('themeToggle').addEventListener('click', toggleTheme);
        
        // Source code download functionality
        document.getElementById('downloadSourceBtn').addEventListener('click', showPasswordDialog);
        document.getElementById('closePasswordDialog').addEventListener('click', hidePasswordDialog);
        document.getElementById('submitPasswordBtn').addEventListener('click', verifyPasswordAndDownload);
        
        // APK download functionality
        document.getElementById('downloadApkBtn').addEventListener('click', showApkPasswordDialog);
        document.getElementById('closeApkPasswordDialog').addEventListener('click', hideApkPasswordDialog);
        document.getElementById('apkPasswordDialog').querySelector('#downloadApkBtn').addEventListener('click', verifyApkPasswordAndDownload);
        
        // Format dialog functionality
        document.getElementById('closeFormatDialog').addEventListener('click', hideFormatDialog);
        const formatButtons = document.querySelectorAll('.download-format-btn');
        formatButtons.forEach(button => {
          button.addEventListener('click', handleFormatSelection);
        });
        
        // Filter dialog functionality
        document.getElementById('closeFilterDialog').addEventListener('click', hideFilterDialog);
        const filterButtons = document.querySelectorAll('.filter-btn');
        filterButtons.forEach(button => {
          button.addEventListener('click', previewFilter);
        });
        document.getElementById('applyFilterBtn').addEventListener('click', applyAndDownloadFilter);
        document.getElementById('keyboardShortcutsBtn').addEventListener('click', toggleShortcutsHelp);
        
        // Crop dialog event listeners
        document.getElementById('closeCropDialog').addEventListener('click', hideCropDialog);
        document.getElementById('applyCropBtn').addEventListener('click', applyCrop);
        document.getElementById('resetCropBtn').addEventListener('click', resetCrop);
        const aspectButtons = document.querySelectorAll('.aspect-btn');
        aspectButtons.forEach(button => {
          button.addEventListener('click', setAspectRatio);
        });
        

        
        // Set up keyboard shortcuts
        document.addEventListener('keydown', handleKeyboardShortcuts);
        
        // Initialize shortcuts help tooltip
        initShortcutsHelp();
        
        // Hide download buttons by default
        document.getElementById('downloadSourceBtn').style.display = 'none';
        document.getElementById('downloadApkBtn').style.display = 'none';
        
        // History feature event listeners
        document.getElementById('historyToggle').addEventListener('change', toggleHistory);
        document.getElementById('searchHistoryBtn').addEventListener('click', searchHistory);
        document.getElementById('clearHistoryBtn').addEventListener('click', clearHistory);
        
        // Initialize history toggle from localStorage
        const historyEnabled = localStorage.getItem('historyEnabled') !== 'false';
        document.getElementById('historyToggle').checked = historyEnabled;
        
        // Set initial toggle label color based on state
        const toggleLabel = document.querySelector('.toggle-label');
        const toggleIcon = document.querySelector('.toggle-label .pulse-icon');
        if (historyEnabled) {
          toggleLabel.style.color = 'var(--primary-color)';
          toggleIcon.style.color = 'var(--primary-color)';
          toggleIcon.style.animation = "pulse-fade 1.5s infinite";
        } else {
          toggleLabel.style.color = 'var(--light-text)';
          toggleIcon.style.color = 'var(--light-text)';
          toggleIcon.style.animation = "none";
          toggleIcon.style.opacity = "0.7";
        }
        
        // Load saved images and history when page loads
        loadSavedImages();
        loadHistory();
        
        // Check for saved theme
        if (localStorage.getItem('theme') === 'light') {
          document.body.classList.add('light-theme');
          document.getElementById('themeToggle').innerHTML = '<i class="fas fa-sun"></i>';
        }
      });
      
      // Function to check for access code in prompt
      function checkForAccessCode(promptText) {
        const downloadSourceBtn = document.getElementById('downloadSourceBtn');
        const downloadApkBtn = document.getElementById('downloadApkBtn');
        
        if (promptText.includes('[access]')) {
          downloadSourceBtn.style.display = 'inline-block';
          downloadApkBtn.style.display = 'inline-block';
        } else if (promptText.includes('[remove]')) {
          downloadSourceBtn.style.display = 'none';
          downloadApkBtn.style.display = 'none';
        }
      }
      
      // Define the convertImageFormat function at global scope so it can be used by other functions
      async function convertImageFormat(blob, format) {
        return new Promise((resolve, reject) => {
          // Create a temporary image element
          const img = new Image();
          img.onload = () => {
            // Create a canvas element
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            
            // Draw the image to the canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            // Set the right mime type
            let mimeType;
            let quality = 0.92;
            
            switch(format) {
              case 'png':
                mimeType = 'image/png';
                break;
              case 'jpeg':
                mimeType = 'image/jpeg';
                break;
              case 'webp':
                mimeType = 'image/webp';
                break;
              default:
                mimeType = 'image/png';
            }
            
            // Convert to the desired format
            canvas.toBlob(
              (blob) => resolve(blob),
              mimeType,
              quality
            );
          };
          
          img.onerror = (error) => {
            reject(error);
          };
          
          // Load the image from blob
          img.src = URL.createObjectURL(blob);
        });
      }
      
      // Current image for filter dialog
      let currentFilterImageUrl = '';
      let currentFilterImageBlob = null;
      
      // Function to show the filter dialog
      function showFilterDialog(imageUrl) {
        currentFilterImageUrl = imageUrl;
        
        // Set the original image source
        const originalImg = document.getElementById('filterOriginalImage');
        const previewImg = document.getElementById('filterPreviewImage');
        originalImg.src = imageUrl;
        previewImg.src = imageUrl;
        
        // Reset active filter button
        document.querySelectorAll('.filter-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector('.filter-btn[data-filter="none"]').classList.add('active');
        
        // Show the dialog
        document.getElementById('filterDialog').style.display = 'flex';
        
        // Preload the image blob for faster processing
        fetch(imageUrl)
          .then(response => response.blob())
          .then(blob => {
            currentFilterImageBlob = blob;
          })
          .catch(err => {
            console.error("Failed to load image for filtering:", err);
          });
      }
      
      // Function to hide the filter dialog
      function hideFilterDialog() {
        document.getElementById('filterDialog').style.display = 'none';
        currentFilterImageUrl = '';
        currentFilterImageBlob = null;
      }
      
      // Preview a filter
      function previewFilter(event) {
        if (!currentFilterImageUrl) return;
        
        // Get selected filter
        const filter = event.currentTarget.dataset.filter;
        
        // Update active button
        document.querySelectorAll('.filter-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        event.currentTarget.classList.add('active');
        
        // Apply filter to preview image
        const previewImg = document.getElementById('filterPreviewImage');
        
        if (filter === 'none') {
          // Reset to original
          previewImg.style.filter = 'none';
          return;
        }
        
        // Apply selected filter
        switch(filter) {
          case 'grayscale':
            previewImg.style.filter = 'grayscale(1)';
            break;
          case 'sepia':
            previewImg.style.filter = 'sepia(0.8)';
            break;
          case 'invert':
            previewImg.style.filter = 'invert(0.8)';
            break;
          case 'saturate':
            previewImg.style.filter = 'saturate(2)';
            break;
          case 'brightness':
            previewImg.style.filter = 'brightness(1.3)';
            break;
          case 'contrast':
            previewImg.style.filter = 'contrast(1.5)';
            break;
          case 'blur':
            previewImg.style.filter = 'blur(2px)';
            break;
          default:
            previewImg.style.filter = 'none';
        }
      }
      
      // Keyboard shortcuts handler
      function handleKeyboardShortcuts(event) {
        // Don't trigger shortcuts if user is typing in an input field
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
          // Exception: Allow Ctrl+Enter in the prompt textarea
          if (event.target.id === 'prompt' && (event.ctrlKey || event.metaKey) && event.key === 'Enter') {
            generateImage();
            event.preventDefault();
          }
          return;
        }
        
        // Shortcuts
        if (event.shiftKey) {
          switch(event.key.toLowerCase()) {
            case 'r': // Shift + R: Random prompt
              generateRandomPrompt();
              event.preventDefault();
              break;
  
            case 'c': // Shift + C: Clear prompt
              clearPrompt();
              event.preventDefault();
              break;
            case 't': // Shift + T: Toggle theme
              toggleTheme();
              event.preventDefault();
              break;
          }
        } else if (event.key === '?') {
          // Toggle shortcuts help
          toggleShortcutsHelp();
          event.preventDefault();
        }
      }
      
      // Initialize shortcuts help tooltip
      function initShortcutsHelp() {
        // Add "?" button to the header
        const helpBtn = document.createElement('button');
        helpBtn.className = 'theme-toggle';
        helpBtn.id = 'shortcutsHelpBtn';
        helpBtn.style.right = '50px';
        helpBtn.innerHTML = '<i class="fas fa-keyboard"></i>';
        helpBtn.title = 'Keyboard Shortcuts (?)';
        helpBtn.addEventListener('click', toggleShortcutsHelp);
        document.body.appendChild(helpBtn);
        
        // Add keyboard shortcut hints to buttons after a slight delay
        setTimeout(() => {
          // Add tooltip info to buttons that have keyboard shortcuts
          addShortcutIndicators();
        }, 500);
      }
      
      // Add shortcut indicators next to button text
      function addShortcutIndicators() {
        const shortcutMap = {
          'generateBtn': 'Ctrl+Enter',
          'randomPromptBtn': 'Shift+R',
          'enhancePromptBtn': 'Shift+E',
          'clearPromptBtn': 'Shift+C',
          'themeToggle': 'Shift+T',
          'shortcutsHelpBtn': '?'
        };
        
        for (const [id, shortcut] of Object.entries(shortcutMap)) {
          const btn = document.getElementById(id);
          if (btn) {
            // Add a small indicator icon with the shortcut
            const indicatorSpan = document.createElement('span');
            indicatorSpan.className = 'shortcut-indicator';
            indicatorSpan.innerHTML = `<kbd>${shortcut}</kbd>`;
            indicatorSpan.style.fontSize = '0.7rem';
            indicatorSpan.style.opacity = '0.7';
            indicatorSpan.style.marginLeft = '5px';
            indicatorSpan.style.display = 'none'; // Initially hidden
            
            // For the theme toggle button, we need special positioning
            if (id === 'themeToggle' || id === 'shortcutsHelpBtn') {
              indicatorSpan.style.position = 'absolute';
              indicatorSpan.style.right = '0';
              indicatorSpan.style.top = '100%';
              indicatorSpan.style.backgroundColor = 'var(--dark-bg)';
              indicatorSpan.style.padding = '3px';
              indicatorSpan.style.borderRadius = '3px';
              btn.style.position = 'relative';
            }
            
            btn.appendChild(indicatorSpan);
            
            // Show the indicator on hover
            btn.addEventListener('mouseenter', () => {
              indicatorSpan.style.display = 'inline-block';
            });
            
            btn.addEventListener('mouseleave', () => {
              indicatorSpan.style.display = 'none';
            });
          }
        }
      }
      
      // Toggle shortcuts help visibility
      function toggleShortcutsHelp() {
        const shortcuts = document.getElementById('shortcuts-help');
        if (shortcuts.style.display === 'block') {
          shortcuts.style.display = 'none';
        } else {
          shortcuts.style.display = 'block';
        }
      }
      
      // Variables for image editing features
      let currentCropImageUrl = '';
      let cropOriginalWidth = 0;
      let cropOriginalHeight = 0;
      let cropX = 0, cropY = 0, cropWidth = 0, cropHeight = 0;
      let isDragging = false;
      let isResizing = false;
      let dragStartX = 0, dragStartY = 0;
      let currentCropAspectRatio = null;
      let cropCanvas, cropCtx, cropOverlay, resizeHandle;
      
      // Variables for background removal
      let currentBgImageUrl = '';
      let bgOriginalImage = null;
      
      // Variables for color correction
      let currentColorImageUrl = '';
      let colorOriginalImageData = null;
      let currentCurveChannel = 'rgb';
      let curvesCanvas, curvesCtx;
      let curvePoints = {
        'rgb': [{x: 0, y: 255}, {x: 255, y: 0}],
        'r': [{x: 0, y: 255}, {x: 255, y: 0}],
        'g': [{x: 0, y: 255}, {x: 255, y: 0}],
        'b': [{x: 0, y: 255}, {x: 255, y: 0}]
      };
      
      // Show crop dialog
      function showCropDialog(imageUrl) {
        currentCropImageUrl = imageUrl;
        
        // Reset crop variables
        cropX = 0;
        cropY = 0;
        cropWidth = 0;
        cropHeight = 0;
        currentCropAspectRatio = null;
        
        // Get canvas and overlay elements
        cropCanvas = document.getElementById('cropCanvas');
        cropCtx = cropCanvas.getContext('2d');
        cropOverlay = document.getElementById('cropOverlay');
        resizeHandle = document.getElementById('resizeHandle');
        
        // Set active aspect ratio button
        document.querySelectorAll('.aspect-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector('.aspect-btn[data-ratio="free"]').classList.add('active');
        
        // Load image and setup cropping
        const img = new Image();
        img.onload = function() {
          // Set canvas size based on image
          cropOriginalWidth = img.width;
          cropOriginalHeight = img.height;
          
          // Resize to fit dialog
          const maxWidth = window.innerWidth * 0.8; // 80% of window width
          const maxHeight = window.innerHeight * 0.5; // 50% of window height
          
          let displayWidth = img.width;
          let displayHeight = img.height;
          
          if (displayWidth > maxWidth) {
            const ratio = maxWidth / displayWidth;
            displayWidth = maxWidth;
            displayHeight = img.height * ratio;
          }
          
          if (displayHeight > maxHeight) {
            const ratio = maxHeight / displayHeight;
            displayHeight = maxHeight;
            displayWidth = displayWidth * ratio;
          }
          
          cropCanvas.width = displayWidth;
          cropCanvas.height = displayHeight;
          
          // Draw image on canvas
          cropCtx.drawImage(img, 0, 0, displayWidth, displayHeight);
          
          // Initialize crop area to the full image
          cropX = 0;
          cropY = 0;
          cropWidth = displayWidth;
          cropHeight = displayHeight;
          
          // Update overlay
          updateCropOverlay();
          
          // Set initial output dimensions
          document.getElementById('cropWidth').value = Math.round(cropOriginalWidth);
          document.getElementById('cropHeight').value = Math.round(cropOriginalHeight);
        };
        img.src = imageUrl;
        
        // Setup drag and resize event handlers
        setupCropInteraction();
        
        // Show the dialog
        document.getElementById('cropDialog').style.display = 'flex';
      }
      
      // Setup crop interaction events
      function setupCropInteraction() {
        cropOverlay.addEventListener('mousedown', startDrag);
        resizeHandle.addEventListener('mousedown', startResize);
        document.addEventListener('mousemove', dragOrResize);
        document.addEventListener('mouseup', stopDragOrResize);
        
        // Touch support
        cropOverlay.addEventListener('touchstart', startDragTouch);
        resizeHandle.addEventListener('touchstart', startResizeTouch);
        document.addEventListener('touchmove', dragOrResizeTouch);
        document.addEventListener('touchend', stopDragOrResize);
        
        // Update crop size when dimensions inputs change
        document.getElementById('cropWidth').addEventListener('input', updateCropFromDimensions);
        document.getElementById('cropHeight').addEventListener('input', updateCropFromDimensions);
      }
      
      // Event handlers for crop interaction
      function startDrag(e) {
        if (e.button !== 0) return; // Only left mouse button
        isDragging = true;
        isResizing = false;
        dragStartX = e.clientX - cropOverlay.getBoundingClientRect().left;
        dragStartY = e.clientY - cropOverlay.getBoundingClientRect().top;
        e.preventDefault();
      }
      
      function startDragTouch(e) {
        isDragging = true;
        isResizing = false;
        const touch = e.touches[0];
        dragStartX = touch.clientX - cropOverlay.getBoundingClientRect().left;
        dragStartY = touch.clientY - cropOverlay.getBoundingClientRect().top;
        e.preventDefault();
      }
      
      function startResize(e) {
        if (e.button !== 0) return; // Only left mouse button
        isResizing = true;
        isDragging = false;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        e.preventDefault();
      }
      
      function startResizeTouch(e) {
        isResizing = true;
        isDragging = false;
        const touch = e.touches[0];
        dragStartX = touch.clientX;
        dragStartY = touch.clientY;
        e.preventDefault();
      }
      
      function dragOrResize(e) {
        if (!isDragging && !isResizing) return;
        
        const rect = cropCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (isDragging) {
          // Move crop overlay
          const newX = x - dragStartX;
          const newY = y - dragStartY;
          
          // Constrain to canvas bounds
          cropX = Math.max(0, Math.min(newX, cropCanvas.width - cropWidth));
          cropY = Math.max(0, Math.min(newY, cropCanvas.height - cropHeight));
        } else if (isResizing) {
          // Resize crop overlay
          let newWidth = x - cropX;
          let newHeight = y - cropY;
          
          // Constrain to canvas bounds
          newWidth = Math.max(50, Math.min(newWidth, cropCanvas.width - cropX));
          newHeight = Math.max(50, Math.min(newHeight, cropCanvas.height - cropY));
          
          // Apply aspect ratio if set
          if (currentCropAspectRatio) {
            if (newWidth / newHeight > currentCropAspectRatio) {
              newWidth = newHeight * currentCropAspectRatio;
            } else {
              newHeight = newWidth / currentCropAspectRatio;
            }
          }
          
          cropWidth = newWidth;
          cropHeight = newHeight;
        }
        
        // Update overlay position and dimensions
        updateCropOverlay();
        
        // Update dimension inputs
        const scaleX = cropOriginalWidth / cropCanvas.width;
        const scaleY = cropOriginalHeight / cropCanvas.height;
        document.getElementById('cropWidth').value = Math.round(cropWidth * scaleX);
        document.getElementById('cropHeight').value = Math.round(cropHeight * scaleY);
        
        e.preventDefault();
      }
      
      function dragOrResizeTouch(e) {
        if (!isDragging && !isResizing) return;
        
        const rect = cropCanvas.getBoundingClientRect();
        const touch = e.touches[0];
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        
        if (isDragging) {
          // Move crop overlay (same logic as mouse)
          const newX = x - dragStartX;
          const newY = y - dragStartY;
          
          cropX = Math.max(0, Math.min(newX, cropCanvas.width - cropWidth));
          cropY = Math.max(0, Math.min(newY, cropCanvas.height - cropHeight));
        } else if (isResizing) {
          // Resize crop overlay (same logic as mouse)
          let newWidth = x - cropX;
          let newHeight = y - cropY;
          
          newWidth = Math.max(50, Math.min(newWidth, cropCanvas.width - cropX));
          newHeight = Math.max(50, Math.min(newHeight, cropCanvas.height - cropY));
          
          if (currentCropAspectRatio) {
            if (newWidth / newHeight > currentCropAspectRatio) {
              newWidth = newHeight * currentCropAspectRatio;
            } else {
              newHeight = newWidth / currentCropAspectRatio;
            }
          }
          
          cropWidth = newWidth;
          cropHeight = newHeight;
        }
        
        updateCropOverlay();
        
        const scaleX = cropOriginalWidth / cropCanvas.width;
        const scaleY = cropOriginalHeight / cropCanvas.height;
        document.getElementById('cropWidth').value = Math.round(cropWidth * scaleX);
        document.getElementById('cropHeight').value = Math.round(cropHeight * scaleY);
        
        e.preventDefault();
      }
      
      function stopDragOrResize() {
        isDragging = false;
        isResizing = false;
      }
      
      function updateCropOverlay() {
        cropOverlay.style.left = cropX + 'px';
        cropOverlay.style.top = cropY + 'px';
        cropOverlay.style.width = cropWidth + 'px';
        cropOverlay.style.height = cropHeight + 'px';
        
        resizeHandle.style.left = (cropX + cropWidth - 5) + 'px';
        resizeHandle.style.top = (cropY + cropHeight - 5) + 'px';
      }
      
      function updateCropFromDimensions() {
        const maintainRatio = document.getElementById('maintainAspectRatio').checked;
        const newWidth = parseInt(document.getElementById('cropWidth').value);
        const newHeight = parseInt(document.getElementById('cropHeight').value);
        
        if (isNaN(newWidth) || isNaN(newHeight) || newWidth <= 0 || newHeight <= 0) return;
        
        const scaleX = cropCanvas.width / cropOriginalWidth;
        const scaleY = cropCanvas.height / cropOriginalHeight;
        
        let canvasWidth = newWidth * scaleX;
        let canvasHeight = newHeight * scaleY;
        
        // Constrain to canvas size
        canvasWidth = Math.min(canvasWidth, cropCanvas.width);
        canvasHeight = Math.min(canvasHeight, cropCanvas.height);
        
        // Apply aspect ratio if needed
        if (maintainRatio && currentCropAspectRatio) {
          const ratio = newWidth / newHeight;
          if (ratio > currentCropAspectRatio) {
            canvasHeight = canvasWidth / currentCropAspectRatio;
          } else {
            canvasWidth = canvasHeight * currentCropAspectRatio;
          }
        }
        
        // Make sure crop area fits in canvas
        cropX = Math.min(cropX, cropCanvas.width - canvasWidth);
        cropY = Math.min(cropY, cropCanvas.height - canvasHeight);
        
        // Update crop dimensions
        cropWidth = canvasWidth;
        cropHeight = canvasHeight;
        
        updateCropOverlay();
      }
      
      function setAspectRatio(e) {
        // Update active button
        document.querySelectorAll('.aspect-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        e.currentTarget.classList.add('active');
        
        const ratio = e.currentTarget.dataset.ratio;
        
        // Calculate aspect ratio
        if (ratio === 'free') {
          currentCropAspectRatio = null;
        } else {
          const [w, h] = ratio.split(':').map(Number);
          currentCropAspectRatio = w / h;
        }
        
        // Adjust crop area to match ratio
        if (currentCropAspectRatio) {
          if (cropWidth / cropHeight > currentCropAspectRatio) {
            cropWidth = cropHeight * currentCropAspectRatio;
          } else {
            cropHeight = cropWidth / currentCropAspectRatio;
          }
          
          // Make sure crop area fits in canvas
          if (cropX + cropWidth > cropCanvas.width) {
            cropWidth = cropCanvas.width - cropX;
            cropHeight = cropWidth / currentCropAspectRatio;
          }
          if (cropY + cropHeight > cropCanvas.height) {
            cropHeight = cropCanvas.height - cropY;
            cropWidth = cropHeight * currentCropAspectRatio;
          }
        }
        
        // Update overlay
        updateCropOverlay();
        
        // Update dimension inputs
        const scaleX = cropOriginalWidth / cropCanvas.width;
        const scaleY = cropOriginalHeight / cropCanvas.height;
        document.getElementById('cropWidth').value = Math.round(cropWidth * scaleX);
        document.getElementById('cropHeight').value = Math.round(cropHeight * scaleY);
      }
      
      function hideCropDialog() {
        document.getElementById('cropDialog').style.display = 'none';
        currentCropImageUrl = '';
      }
      
      function resetCrop() {
        // Reset crop area to full canvas
        cropX = 0;
        cropY = 0;
        cropWidth = cropCanvas.width;
        cropHeight = cropCanvas.height;
        
        // Update overlay
        updateCropOverlay();
        
        // Reset aspect ratio
        currentCropAspectRatio = null;
        document.querySelectorAll('.aspect-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector('.aspect-btn[data-ratio="free"]').classList.add('active');
        
        // Update dimension inputs
        document.getElementById('cropWidth').value = Math.round(cropOriginalWidth);
        document.getElementById('cropHeight').value = Math.round(cropOriginalHeight);
      }
      
      function applyCrop() {
        if (!currentCropImageUrl) return;
        
        const applyCropBtn = document.getElementById('applyCropBtn');
        applyCropBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
        applyCropBtn.disabled = true;
        
        try {
          // Create a new canvas for the cropped image
          const outputCanvas = document.createElement('canvas');
          const outputWidth = parseInt(document.getElementById('cropWidth').value);
          const outputHeight = parseInt(document.getElementById('cropHeight').value);
          
          outputCanvas.width = outputWidth;
          outputCanvas.height = outputHeight;
          const outputCtx = outputCanvas.getContext('2d');
          
          // Calculate source coordinates
          const scaleX = cropOriginalWidth / cropCanvas.width;
          const scaleY = cropOriginalHeight / cropCanvas.height;
          
          const sourceX = cropX * scaleX;
          const sourceY = cropY * scaleY;
          const sourceWidth = cropWidth * scaleX;
          const sourceHeight = cropHeight * scaleY;
          
          // Load original image at full resolution
          const img = new Image();
          img.onload = function() {
            // Draw cropped portion to output canvas
            outputCtx.drawImage(
              img,
              sourceX, sourceY, sourceWidth, sourceHeight,
              0, 0, outputWidth, outputHeight
            );
            
            // Convert to blob and download
            outputCanvas.toBlob(function(blob) {
              const blobUrl = URL.createObjectURL(blob);
              
              // Create download link
              const a = document.createElement('a');
              a.href = blobUrl;
              a.download = `cropped-image.png`;
              a.style.display = 'none';
              document.body.appendChild(a);
              
              // Trigger download
              setTimeout(() => {
                a.click();
                
                // Cleanup
                setTimeout(() => {
                  document.body.removeChild(a);
                  URL.revokeObjectURL(blobUrl);
                  
                  // Reset button and hide dialog
                  applyCropBtn.innerHTML = '<i class="fas fa-crop"></i> Apply & Download';
                  applyCropBtn.disabled = false;
                  hideCropDialog();
                }, 100);
              }, 100);
            });
          };
          
          img.src = currentCropImageUrl;
        } catch (err) {
          console.error("Crop failed:", err);
          alert("Failed to crop image: " + (err.message || "Unknown error"));
          
          applyCropBtn.innerHTML = '<i class="fas fa-crop"></i> Apply & Download';
          applyCropBtn.disabled = false;
        }
      }
      
      // Background Removal Functions
      function showBgRemovalDialog(imageUrl) {
        currentBgImageUrl = imageUrl;
        
        // Set the original image
        const originalImg = document.getElementById('bgOriginalImage');
        originalImg.src = imageUrl;
        
        // Show the dialog
        document.getElementById('bgRemovalDialog').style.display = 'flex';
        
        // Initialize the preview
        originalImg.onload = function() {
          // Store original image for processing
          bgOriginalImage = originalImg;
          
          // First preview
          updateBgRemovalPreview();
        };
      }
      
      function hideBgRemovalDialog() {
        document.getElementById('bgRemovalDialog').style.display = 'none';
        currentBgImageUrl = '';
        bgOriginalImage = null;
      }
      
      function updateBgRemovalPreview() {
        if (!bgOriginalImage) return;
        
        // Get threshold values
        const tolerance = parseInt(document.getElementById('toleranceSlider').value);
        const smoothing = parseInt(document.getElementById('smoothingSlider').value);
        
        // Update display values
        document.getElementById('toleranceValue').textContent = tolerance + '%';
        document.getElementById('smoothingValue').textContent = smoothing + '%';
        
        // Create canvas for processing
        const canvas = document.createElement('canvas');
        canvas.width = bgOriginalImage.naturalWidth;
        canvas.height = bgOriginalImage.naturalHeight;
        const ctx = canvas.getContext('2d');
        
        // Draw original image
        ctx.drawImage(bgOriginalImage, 0, 0);
        
        // Get image data
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Simple background removal algorithm (chroma key-like)
        // For a real implementation, more sophisticated algorithms would be needed
        // We'll use the corners to determine background color
        
        // Sample corners for background color
        const topLeft = [data[0], data[1], data[2], data[3]];
        const topRight = [data[(canvas.width - 1) * 4], data[(canvas.width - 1) * 4 + 1], data[(canvas.width - 1) * 4 + 2], data[(canvas.width - 1) * 4 + 3]];
        const bottomLeft = [data[(canvas.height - 1) * canvas.width * 4], data[(canvas.height - 1) * canvas.width * 4 + 1], data[(canvas.height - 1) * canvas.width * 4 + 2], data[(canvas.height - 1) * canvas.width * 4 + 3]];
        const bottomRight = [data[((canvas.height - 1) * canvas.width + (canvas.width - 1)) * 4], data[((canvas.height - 1) * canvas.width + (canvas.width - 1)) * 4 + 1], data[((canvas.height - 1) * canvas.width + (canvas.width - 1)) * 4 + 2], data[((canvas.height - 1) * canvas.width + (canvas.width - 1)) * 4 + 3]];
        
        // Average the samples
        const bgColor = [
          (topLeft[0] + topRight[0] + bottomLeft[0] + bottomRight[0]) / 4,
          (topLeft[1] + topRight[1] + bottomLeft[1] + bottomRight[1]) / 4,
          (topLeft[2] + topRight[2] + bottomLeft[2] + bottomRight[2]) / 4
        ];
        
        // Remove background
        const toleranceVal = tolerance * 2.55; // Convert to 0-255 scale
        const smoothingVal = smoothing / 100; // 0-1 scale
        
        for (let i = 0; i < data.length; i += 4) {
          // Calculate color distance
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          
          const distance = Math.sqrt(
            Math.pow(r - bgColor[0], 2) +
            Math.pow(g - bgColor[1], 2) +
            Math.pow(b - bgColor[2], 2)
          );
          
          // Apply transparency based on distance
          if (distance < toleranceVal) {
            // Calculate alpha based on distance and smoothing
            let alpha = (distance / toleranceVal) * 255;
            alpha = Math.max(0, Math.min(255, alpha));
            
            // Apply smoothing
            alpha = Math.pow(alpha / 255, smoothingVal) * 255;
            
            data[i + 3] = alpha;
          }
        }
        
        // Put modified image data back
        ctx.putImageData(imageData, 0, 0);
        
        // Display result
        document.getElementById('bgRemovedImage').src = canvas.toDataURL('image/png');
      }
      
      function resetBgRemoval() {
        document.getElementById('toleranceSlider').value = 30;
        document.getElementById('smoothingSlider').value = 50;
        document.getElementById('toleranceValue').textContent = '30%';
        document.getElementById('smoothingValue').textContent = '50%';
        
        updateBgRemovalPreview();
      }
      
      function applyBgRemoval() {
        if (!currentBgImageUrl || !bgOriginalImage) return;
        
        const applyBtn = document.getElementById('applyBgRemovalBtn');
        applyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
        applyBtn.disabled = true;
        
        try {
          // Convert the displayed result to a download
          const resultImg = document.getElementById('bgRemovedImage');
          
          // Create download link
          const a = document.createElement('a');
          a.href = resultImg.src; // Already a data URL
          a.download = 'background-removed.png';
          a.style.display = 'none';
          document.body.appendChild(a);
          
          // Trigger download
          setTimeout(() => {
            a.click();
            
            // Cleanup
            setTimeout(() => {
              document.body.removeChild(a);
              
              // Reset button and hide dialog
              applyBtn.innerHTML = '<i class="fas fa-eraser"></i> Apply & Download';
              applyBtn.disabled = false;
              hideBgRemovalDialog();
            }, 100);
          }, 100);
        } catch (err) {
          console.error("Background removal failed:", err);
          alert("Failed to remove background: " + (err.message || "Unknown error"));
          
          applyBtn.innerHTML = '<i class="fas fa-eraser"></i> Apply & Download';
          applyBtn.disabled = false;
        }
      }
      
      // Color Correction Functions
      function showColorCorrectionDialog(imageUrl) {
        currentColorImageUrl = imageUrl;
        
        // Set the original image
        const originalImg = document.getElementById('colorOriginalImage');
        const correctedImg = document.getElementById('colorCorrectedImage');
        originalImg.src = imageUrl;
        correctedImg.src = imageUrl;
        
        // Initialize the canvas for curves
        curvesCanvas = document.getElementById('curvesCanvas');
        curvesCtx = curvesCanvas.getContext('2d');
        
        // Reset all sliders
        resetColorCorrection();
        
        // Set active tab
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector('.tab-btn[data-tab="basic"]').classList.add('active');
        
        document.querySelectorAll('.tab-content').forEach(content => {
          content.style.display = 'none';
        });
        document.getElementById('basicTab').style.display = 'block';
        
        // Show the dialog
        document.getElementById('colorCorrectionDialog').style.display = 'flex';
        
        // Store original image data for processing
        originalImg.onload = function() {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = originalImg.naturalWidth;
          tempCanvas.height = originalImg.naturalHeight;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(originalImg, 0, 0);
          colorOriginalImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
          
          // Initial draw for curves
          drawCurvesEditor();
        };
      }
      
      function hideColorCorrectionDialog() {
        document.getElementById('colorCorrectionDialog').style.display = 'none';
        currentColorImageUrl = '';
        colorOriginalImageData = null;
      }
      
      function switchTab(e) {
        // Update active tab button
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        e.currentTarget.classList.add('active');
        
        // Show selected tab content
        const tabId = e.currentTarget.dataset.tab;
        document.querySelectorAll('.tab-content').forEach(content => {
          content.style.display = 'none';
        });
        document.getElementById(`${tabId}Tab`).style.display = 'block';
        
        // If switching to curves tab, redraw the curves
        if (tabId === 'curves') {
          drawCurvesEditor();
        }
      }
      
      function switchCurveChannel(e) {
        // Update active channel button
        document.querySelectorAll('.curve-channel-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        e.currentTarget.classList.add('active');
        
        // Set current channel
        currentCurveChannel = e.currentTarget.dataset.channel;
        
        // Redraw curves
        drawCurvesEditor();
      }
      
      function drawCurvesEditor() {
        if (!curvesCanvas || !curvesCtx) return;
        
        // Clear canvas
        curvesCtx.clearRect(0, 0, curvesCanvas.width, curvesCanvas.height);
        
        // Draw grid
        curvesCtx.strokeStyle = 'rgba(255, 255, 255,.1)';
        curvesCtx.beginPath();
        
        // Vertical grid lines
        for (let x = 0; x <= curvesCanvas.width; x += curvesCanvas.width / 10) {
          curvesCtx.moveTo(x, 0);
          curvesCtx.lineTo(x, curvesCanvas.height);
        }
        
        // Horizontal grid lines
        for (let y = 0; y <= curvesCanvas.height; y += curvesCanvas.height / 10) {
          curvesCtx.moveTo(0, y);
          curvesCtx.lineTo(curvesCanvas.width, y);
        }
        
        curvesCtx.stroke();
        
        // Draw diagonal line (neutral)
        curvesCtx.strokeStyle = 'rgba(255, 255, 255, .5)';
        curvesCtx.beginPath();
        curvesCtx.moveTo(0, curvesCanvas.height);
        curvesCtx.lineTo(curvesCanvas.width, 0);
        curvesCtx.stroke();
        
        // Draw curve for active channel
        const points = curvePoints[currentCurveChannel];
        
        // Sort points by x value
        points.sort((a, b) => a.x - b.x);
        
        // Draw curve
        curvesCtx.strokeStyle = getChannelColor(currentCurveChannel);
        curvesCtx.lineWidth = 2;
        curvesCtx.beginPath();
        
        // Draw curve as a series of straight lines between points
        curvesCtx.moveTo(
          (points[0].x / 255) * curvesCanvas.width,
          curvesCanvas.height - (points[0].y / 255) * curvesCanvas.height
        );
        
        for (let i = 1; i < points.length; i++) {
          const x = (points[i].x / 255) * curvesCanvas.width;
          const y = curvesCanvas.height - (points[i].y / 255) * curvesCanvas.height;
          curvesCtx.lineTo(x, y);
        }
        
        curvesCtx.stroke();
      }
      
      function getChannelColor(channel) {
        switch(channel) {
          case 'r': return 'rgb(255, 100, 100)';
          case 'g': return 'rgb(100, 255, 100)';
          case 'b': return 'rgb(100, 100, 255)';
          default: return 'rgb(255, 255, 255)';
        }
      }
      
      function updateCurvePoint(x, y) {
        // Normalize coordinates
        const normX = Math.max(0, Math.min(255, Math.round((x / curvesCanvas.width) * 255)));
        const normY = Math.max(0, Math.min(255, Math.round((1 - y / curvesCanvas.height) * 255)));
        
        // Find if there's a point near this location
        let pointIndex = -1;
        let minDist = 15; // Pixel distance threshold
        
        for (let i = 0; i < curvePoints[currentCurveChannel].length; i++) {
          const point = curvePoints[currentCurveChannel][i];
          const px = (point.x / 255) * curvesCanvas.width;
          const py = curvesCanvas.height - (point.y / 255) * curvesCanvas.height;
          
          const dist = Math.sqrt(Math.pow(px - x, 2) + Math.pow(py - y, 2));
          if (dist < minDist) {
            pointIndex = i;
            break;
          }
        }
        
        // Update or add point
        if (pointIndex !== -1) {
          curvePoints[currentCurveChannel][pointIndex] = {x: normX, y: normY};
        } else {
          curvePoints[currentCurveChannel].push({x: normX, y: normY});
        }
        
        // Redraw
        drawCurvesEditor();
      }
      
      function resetCurves() {
        // Reset curve points to default
        curvePoints = {
          'rgb': [{x: 0, y: 255}, {x: 255, y: 0}],
          'r': [{x: 0, y: 255}, {x: 255, y: 0}],
          'g': [{x: 0, y: 255}, {x: 255, y: 0}],
          'b': [{x: 0, y: 255}, {x: 255, y: 0}]
        };
        
        // Redraw curves
        drawCurvesEditor();
      }
      
      function resetColorCorrection() {
        // Reset all sliders
        const sliders = [
          'brightnessSlider', 'contrastSlider', 'saturationSlider', 'hueSlider',
          'redSlider', 'greenSlider', 'blueSlider',
          'highlightsSlider', 'midtonesSlider', 'shadowsSlider'
        ];
        
        sliders.forEach(slider => {
          const element = document.getElementById(slider);
          if (element) {
            element.value = 0;
            document.getElementById(`${slider.replace('Slider', '')}Value`).textContent = '0';
          }
        });
        
        // Reset curves
        resetCurves();
        
        // Reset preview
        if (currentColorImageUrl) {
          document.getElementById('colorCorrectedImage').src = currentColorImageUrl;
        }
      }
      
      function applyColorCorrection() {
        if (!currentColorImageUrl || !colorOriginalImageData) return;
        
        const applyBtn = document.getElementById('applyColorCorrectionBtn');
        applyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
        applyBtn.disabled = true;
        
        try {
          // Create canvas for processing
          const canvas = document.createElement('canvas');
          canvas.width = colorOriginalImageData.width;
          canvas.height = colorOriginalImageData.height;
          const ctx = canvas.getContext('2d');
          
          // Create a copy of the original image data
          const imageData = new ImageData(
            new Uint8ClampedArray(colorOriginalImageData.data),
            colorOriginalImageData.width,
            colorOriginalImageData.height
          );
          
          // Get adjustment values
          const brightness = parseInt(document.getElementById('brightnessSlider').value) / 100;
          const contrast = parseInt(document.getElementById('contrastSlider').value) / 100;
          const saturation = parseInt(document.getElementById('saturationSlider').value) / 100;
          const hueShift = parseInt(document.getElementById('hueSlider').value);
          
          const redAdjust = parseInt(document.getElementById('redSlider').value) / 100;
          const greenAdjust = parseInt(document.getElementById('greenSlider').value) / 100;
          const blueAdjust = parseInt(document.getElementById('blueSlider').value) / 100;
          
          const highlightsAdjust = parseInt(document.getElementById('highlightsSlider').value) / 100;
          const midtonesAdjust = parseInt(document.getElementById('midtonesSlider').value) / 100;
          const shadowsAdjust = parseInt(document.getElementById('shadowsSlider').value) / 100;
          
          // Apply adjustments
          const data = imageData.data;
          for (let i = 0; i < data.length; i += 4) {
            // Get pixel values
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            // Apply hue adjustment by converting to HSL
            if (hueShift !== 0) {
              const [h, s, l] = rgbToHsl(r, g, b);
              const newHue = (h + hueShift / 360) % 1;
              [r, g, b] = hslToRgb(newHue, s, l);
            }
            
            // Apply saturation
            if (saturation !== 0) {
              const [h, s, l] = rgbToHsl(r, g, b);
              const newSat = Math.max(0, Math.min(1, s * (1 + saturation)));
              [r, g, b] = hslToRgb(h, newSat, l);
            }
            
            // Apply brightness
            if (brightness !== 0) {
              r = Math.max(0, Math.min(255, r + brightness * 255));
              g = Math.max(0, Math.min(255, g + brightness * 255));
              b = Math.max(0, Math.min(255, b + brightness * 255));
            }
            
            // Apply contrast
            if (contrast !== 0) {
              const factor = (1 + contrast) * (1 + contrast);
              const midpoint = 128;
              
              r = Math.max(0, Math.min(255, midpoint + (r - midpoint) * factor));
              g = Math.max(0, Math.min(255, midpoint + (g - midpoint) * factor));
              b = Math.max(0, Math.min(255, midpoint + (b - midpoint) * factor));
            }
            
            // Apply RGB channel adjustments
            if (redAdjust !== 0) {
              r = Math.max(0, Math.min(255, r * (1 + redAdjust)));
            }
            if (greenAdjust !== 0) {
              g = Math.max(0, Math.min(255, g * (1 + greenAdjust)));
            }
            if (blueAdjust !== 0) {
              b = Math.max(0, Math.min(255, b * (1 + blueAdjust)));
            }
            
            // Apply tone adjustments (highlights, midtones, shadows)
            let luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
            
            // Highlights adjustment (affects brighter areas more)
            if (highlightsAdjust !== 0) {
              const highlightFactor = Math.pow(luminance, 1.5) * highlightsAdjust;
              r = Math.max(0, Math.min(255, r + highlightFactor * 255));
              g = Math.max(0, Math.min(255, g + highlightFactor * 255));
              b = Math.max(0, Math.min(255, b + highlightFactor * 255));
            }
            
            // Midtones adjustment (bell curve centered at 0.5)
            if (midtonesAdjust !== 0) {
              const midtoneFactor = (1 - Math.abs(luminance - 0.5) * 2) * midtonesAdjust;
              r = Math.max(0, Math.min(255, r + midtoneFactor * 255));
              g = Math.max(0, Math.min(255, g + midtoneFactor * 255));
              b = Math.max(0, Math.min(255, b + midtoneFactor * 255));
            }
            
            // Shadows adjustment (affects darker areas more)
            if (shadowsAdjust !== 0) {
              const shadowFactor = Math.pow(1 - luminance, 1.5) * shadowsAdjust;
              r = Math.max(0, Math.min(255, r + shadowFactor * 255));
              g = Math.max(0, Math.min(255, g + shadowFactor * 255));
              b = Math.max(0, Math.min(255, b + shadowFactor * 255));
            }
            
            // Apply the adjustments
            data[i] = Math.round(r);
            data[i + 1] = Math.round(g);
            data[i + 2] = Math.round(b);
          }
          
          // Put the processed image data on the canvas
          ctx.putImageData(imageData, 0, 0);
          
          // Convert to blob and download
          canvas.toBlob(function(blob) {
            const blobUrl = URL.createObjectURL(blob);
            
            // Create download link
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = 'color-corrected.png';
            a.style.display = 'none';
            document.body.appendChild(a);
            
            // Trigger download
            setTimeout(() => {
              a.click();
              
              // Cleanup
              setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(blobUrl);
                
                // Reset button and hide dialog
                applyBtn.innerHTML = '<i class="fas fa-palette"></i> Apply & Download';
                applyBtn.disabled = false;
                hideColorCorrectionDialog();
              }, 100);
            }, 100);
          });
        } catch (err) {
          console.error("Color correction failed:", err);
          alert("Failed to apply color correction: " + (err.message || "Unknown error"));
          
          applyBtn.innerHTML = '<i class="fas fa-palette"></i> Apply & Download';
          applyBtn.disabled = false;
        }
      }
      
      // Helper functions for color conversions
      function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0; // achromatic
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          
          h /= 6;
        }
        
        return [h, s, l];
      }
      
      function hslToRgb(h, s, l) {
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l; // achromatic
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        return [r * 255, g * 255, b * 255];
      }
      
      // Apply filter and download the image
      function applyAndDownloadFilter() {
        if (!currentFilterImageUrl) return;
        
        const applyBtn = document.getElementById('applyFilterBtn');
        applyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
        applyBtn.disabled = true;
        
        // Get the active filter
        const activeFilterBtn = document.querySelector('.filter-btn.active');
        const filter = activeFilterBtn ? activeFilterBtn.dataset.filter : 'none';
        
        if (filter === 'none') {
          // Just download the original
          downloadWithFilter(currentFilterImageUrl, 'none');
          return;
        }
        
        // Use the Canvas API to apply the filter
        const img = new Image();
        img.crossOrigin = "Anonymous";
        
        img.onload = function() {
          // Create canvas
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          
          // Draw image to canvas
          ctx.drawImage(img, 0, 0, img.width, img.height);
          
          // Apply the selected filter using pixel manipulation
          switch(filter) {
            case 'grayscale':
              applyGrayscale(ctx, canvas);
              break;
            case 'sepia':
              applySepia(ctx, canvas);
              break;
            case 'invert':
              applyInvert(ctx, canvas);
              break;
            case 'saturate':
              applySaturate(ctx, canvas);
              break;  
            case 'brightness':
              applyBrightness(ctx, canvas);
              break;
            case 'contrast':
              applyContrast(ctx, canvas);
              break;
            case 'blur':
              applyBlur(ctx, canvas);
              break;
          }
          
          // Convert to blob and download
          canvas.toBlob(function(blob) {
            const blobUrl = URL.createObjectURL(blob);
            
            // Create and trigger download
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = `filtered-image-${filter}.png`;
            a.style.display = 'none';
            document.body.appendChild(a);
            
            setTimeout(() => {
              a.click();
              
              setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(blobUrl);
                
                // Reset button and hide dialog
                applyBtn.innerHTML = '<i class="fas fa-check"></i> Apply Filter & Download';
                applyBtn.disabled = false;
                hideFilterDialog();
                
              }, 100);
            }, 100);
          });
        };
        
        img.onerror = function() {
          console.error("Failed to load image for filtering");
          alert("Failed to apply filter. Please try again.");
          
          applyBtn.innerHTML = '<i class="fas fa-check"></i> Apply Filter & Download';
          applyBtn.disabled = false;
        };
        
        // Use blob URL if available, otherwise use the image URL
        if (currentFilterImageBlob) {
          img.src = URL.createObjectURL(currentFilterImageBlob);
        } else {
          img.src = currentFilterImageUrl;
        }
      }
      
      // Helper function to download with a filter
      function downloadWithFilter(url, filter) {
        const a = document.createElement('a');
        a.href = url;
        a.download = `image-${filter || 'original'}.png`;
        a.style.display = 'none';
        document.body.appendChild(a);
        
        setTimeout(() => {
          a.click();
          
          setTimeout(() => {
            document.body.removeChild(a);
            
            // Reset button and hide dialog
            const applyBtn = document.getElementById('applyFilterBtn');
            applyBtn.innerHTML = '<i class="fas fa-check"></i> Apply Filter & Download';
            applyBtn.disabled = false;
            hideFilterDialog();
            
          }, 100);
        }, 100);
      }
      
      // Filter implementation functions
      function applyGrayscale(ctx, canvas) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
          const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
          data[i] = avg; // red
          data[i + 1] = avg; // green
          data[i + 2] = avg; // blue
        }
        
        ctx.putImageData(imageData, 0, 0);
      }
      
      function applySepia(ctx, canvas) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          
          data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
          data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
          data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
        }
        
        ctx.putImageData(imageData, 0, 0);
      }
      
      function applyInvert(ctx, canvas) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
          data[i] = 255 - data[i]; // red
          data[i + 1] = 255 - data[i + 1]; // green
          data[i + 2] = 255 - data[i + 2]; // blue
        }
        
        ctx.putImageData(imageData, 0, 0);
      }
      
      function applySaturate(ctx, canvas) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const amt = 2; // Amount of saturation
        
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          
          // Convert RGB to HSL
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;
          
          if (max === min) {
            h = s = 0; // achromatic
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            
            h /= 6;
          }
          
          // Increase saturation
          s = Math.min(1, s * amt);
          
          // Convert back to RGB
          if (s === 0) {
            data[i] = data[i + 1] = data[i + 2] = l * 255;
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            
            data[i] = hue2rgb(p, q, h + 1/3) * 255;
            data[i + 1] = hue2rgb(p, q, h) * 255;
            data[i + 2] = hue2rgb(p, q, h - 1/3) * 255;
          }
        }
        
        ctx.putImageData(imageData, 0, 0);
      }
      
      function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      }
      
      function applyBrightness(ctx, canvas) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const factor = 1.3; // Brightness factor (>1 = brighter)
        
        for (let i = 0; i < data.length; i += 4) {
          data[i] = Math.min(255, data[i] * factor);
          data[i + 1] = Math.min(255, data[i + 1] * factor);
          data[i + 2] = Math.min(255, data[i + 2] * factor);
        }
        
        ctx.putImageData(imageData, 0, 0);
      }
      
      function applyContrast(ctx, canvas) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const factor = 1.5; // Contrast factor (>1 = more contrast)
        
        const avgLuminance = 128; // Middle gray
        
        for (let i = 0; i < data.length; i += 4) {
          data[i] = avgLuminance + (data[i] - avgLuminance) * factor;
          data[i + 1] = avgLuminance + (data[i + 1] - avgLuminance) * factor;
          data[i + 2] = avgLuminance + (data[i + 2] - avgLuminance) * factor;
        }
        
        ctx.putImageData(imageData, 0, 0);
      }
      
      function applyBlur(ctx, canvas) {
        // Simple box blur implementation
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;
        const width = canvas.width;
        const height = canvas.height;
        
        // Create a temporary array to hold the blurred result
        const result = new Uint8ClampedArray(pixels.length);
        
        // Amount of blur (radius)
        const radius = 2;
        const diameter = radius * 2 + 1;
        
        // Simple box blur algorithm (not very efficient but illustrative)
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let r = 0, g = 0, b = 0, a = 0;
            let count = 0;
            
            // Sample the surrounding pixels
            for (let ky = -radius; ky <= radius; ky++) {
              for (let kx = -radius; kx <= radius; kx++) {
                const pixelX = Math.min(width - 1, Math.max(0, x + kx));
                const pixelY = Math.min(height - 1, Math.max(0, y + ky));
                
                const idx = (pixelY * width + pixelX) * 4;
                r += pixels[idx];
                g += pixels[idx + 1];
                b += pixels[idx + 2];
                a += pixels[idx + 3];
                count++;
              }
            }
            
            // Average the values
            const resultIdx = (y * width + x) * 4;
            result[resultIdx] = r / count;
            result[resultIdx + 1] = g / count;
            result[resultIdx + 2] = b / count;
            result[resultIdx + 3] = a / count;
          }
        }
        
        // Copy the blurred result back to the original imageData
        for (let i = 0; i < pixels.length; i++) {
          pixels[i] = result[i];
        }
        
        // Put the modified pixel data back on the canvas
        ctx.putImageData(imageData, 0, 0);
      }

      // Current image being processed for download
      let currentDownloadImageUrl = '';
      let currentDownloadImageIndex = 0;
      
      // Function to show the format selection dialog
      function showFormatDialog(event) {
        const formatDialog = document.getElementById('formatDialog');
        
        // Store the image URL and index from the button's dataset
        currentDownloadImageUrl = event.currentTarget.dataset.imageUrl;
        currentDownloadImageIndex = event.currentTarget.dataset.imageIndex;
        
        // Show the dialog
        formatDialog.style.display = 'flex';
      }
      
      // Function to hide the format selection dialog
      function hideFormatDialog() {
        document.getElementById('formatDialog').style.display = 'none';
      }
      
      // Function to handle format selection and trigger download
      async function handleFormatSelection(event) {
        if (!currentDownloadImageUrl) {
          alert('No image selected for download');
          hideFormatDialog();
          return;
        }
        
        try {
          // Get the selected format from the button's data attribute
          const format = event.currentTarget.dataset.format;
          
          // Show feedback immediately
          event.currentTarget.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Downloading...`;
          event.currentTarget.disabled = true;
          
          // Fetch image data
          const response = await fetch(currentDownloadImageUrl);
          const blob = await response.blob();
          
          // Convert to desired format
          const convertedBlob = await convertImageFormat(blob, format);
          
          // Set correct mime type and filename extension
          const mimeTypes = {
            'png': 'image/png',
            'jpeg': 'image/jpeg',
            'webp': 'image/webp',
          };
          
          // Force download filename and mime type
          const filename = `neon-image-${currentDownloadImageIndex}.${format}`;
          const blobWithType = new Blob([convertedBlob], {type: mimeTypes[format]});
          const blobUrl = URL.createObjectURL(blobWithType);
          
          // Create and trigger download
          const a = document.createElement('a');
          a.href = blobUrl;
          a.download = filename; 
          a.style.display = 'none';
          a.setAttribute('target', '_self');
          a.setAttribute('rel', 'noopener noreferrer');
          
          // This helps with download triggering in Firefox
          document.body.appendChild(a);
          
          // Trigger the click event after a short delay
          setTimeout(() => {
            a.click();
            
            // Cleanup
            setTimeout(() => {
              document.body.removeChild(a);
              URL.revokeObjectURL(blobUrl);
              
              // Hide the dialog and reset button state
              hideFormatDialog();
              
              // Reset format button content
              document.querySelectorAll('.download-format-btn').forEach(btn => {
                const format = btn.dataset.format;
                btn.innerHTML = `
                  <i class="fas fa-file-image"></i> ${format.toUpperCase()} Format
                  <span style="font-size: 0.8rem; display: block; margin-top: 0.3rem; color: var(--light-text);">
                    ${format === 'png' ? 'Best quality, larger file size' : 
                      format === 'jpeg' ? 'Good quality, smaller file size' : 
                      'Modern format, best compression'}
                  </span>
                `;
                btn.disabled = false;
              });
              
            }, 1000); // Longer timeout for cleanup
          }, 100);
        } catch (err) {
          console.error("Download failed:", err);
          alert("Failed to download image: " + (err.message || "Unknown error"));
          
          // Hide the dialog and reset button state
          hideFormatDialog();
          
          // Reset format button content
          document.querySelectorAll('.download-format-btn').forEach(btn => {
            btn.disabled = false;
            const format = btn.dataset.format;
            btn.innerHTML = `
              <i class="fas fa-file-image"></i> ${format.toUpperCase()} Format
              <span style="font-size: 0.8rem; display: block; margin-top: 0.3rem; color: var(--light-text);">
                ${format === 'png' ? 'Best quality, larger file size' : 
                  format === 'jpeg' ? 'Good quality, smaller file size' : 
                  'Modern format, best compression'}
              </span>
            `;
          });
        }
      }
      
      // Collection of random prompts
      const randomPrompts = [
        "A cyberpunk city at night with neon lights and holographic advertisements",
        "A futuristic cyborg with glowing parts in a dark technoir setting",
        "A digital landscape with neon grid lines and geometric shapes",
        "An AI consciousness represented as glowing energy in virtual space",
        "A neon-lit underground hacker den with multiple screens",
        "A retro-futuristic vehicle on a dark highway with light trails",
        "A synthetic being emerging from digital code with neon accents",
        "A dystopian metropolis with towering structures and flying vehicles",
        "A robotic face with glowing eyes against a dark background",
        "A digital realm with data visualizations and flowing energy",
        "Ancient ruins with futuristic technology in an overgrown jungle",
        "Biomechanical creature with glowing energy veins in a neon laboratory",
        "Cosmic being made of stars and nebulae creating a new galaxy",
        "Quantum computer core visualization with flowing light particles",
        "Post-apocalyptic city reclaimed by nature with bioluminescent plants"
      ];
      
      // Generate random prompt
      function generateRandomPrompt() {
        const promptTextarea = document.getElementById('prompt');
        const randomIndex = Math.floor(Math.random() * randomPrompts.length);
        promptTextarea.value = randomPrompts[randomIndex];
      }
      
      // Enhance existing prompt
      function enhancePrompt() {
        const promptTextarea = document.getElementById('prompt');
        let currentPrompt = promptTextarea.value.trim();
        const errorDiv = document.getElementById('error');
        
        if (!currentPrompt) {
          errorDiv.style.display = 'block';
          errorDiv.textContent = 'Please enter a prompt to enhance';
          return;
        }
        
        errorDiv.style.display = 'none';
        
        // Add enhancing elements to the prompt
        const enhancements = [
          ", neon lighting", 
          ", cyberpunk style", 
          ", futuristic", 
          ", digital art", 
          ", glowing accents",
          ", synthwave",
          ", dystopian future",
          ", holographic details",
          ", sci-fi aesthetic",
          ", ultra detailed"
        ];
        
        // Select 2-3 random enhancements
        const numEnhancements = Math.floor(Math.random() * 2) + 2;
        const selectedEnhancements = [];
        
        for (let i = 0; i < numEnhancements; i++) {
          const randomIndex = Math.floor(Math.random() * enhancements.length);
          // Avoid duplicates
          if (!selectedEnhancements.includes(enhancements[randomIndex])) {
            selectedEnhancements.push(enhancements[randomIndex]);
          }
        }
        
        // Apply enhancements
        promptTextarea.value = currentPrompt + selectedEnhancements.join('');
      }
      
      // Super enhance prompt library categorized by subject matter
      const promptEnhancers = {
        // Descriptive quality enhancers - used for all prompts
        quality: [
          "masterfully crafted", "stunning", "breathtaking", "photorealistic", "hyperrealistic", 
          "highly detailed", "intricate details", "lifelike", "ultra realistic", "immaculate", 
          "flawless", "pristine", "impeccable craftsmanship", "exquisite", "extraordinary", 
          "meticulous", "precise details", "8K resolution", "sharp focus", "award-winning",
          "studio quality", "professional", "cinematic", "museum quality", "gallery worthy"
        ],
        
        // Technical elements enhancers
        technical: [
          "perfect lighting", "dramatic lighting", "volumetric lighting", "ambient lighting", "soft lighting",
          "golden hour lighting", "blue hour", "rim lighting", "backlighting", "studio lighting",
          "natural lighting", "dramatic shadows", "ray tracing", "global illumination", "HDR",
          "physically-based rendering", "subsurface scattering", "color grading", "tone mapping", "post-processing",
          "depth of field", "shallow depth of field", "bokeh effect", "vignette", "chromatic aberration",
          "high contrast", "dynamic range", "high dynamic range", "color calibrated", "color corrected"
        ],
        
        // Composition enhancers
        composition: [
          "rule of thirds", "leading lines", "balanced composition", "symmetrical", "asymmetrical composition",
          "foreground interest", "middleground", "background details", "sense of scale", "macro perspective",
          "low angle", "high angle", "aerial view", "bird's eye view", "worm's eye view",
          "wide angle", "telephoto", "panoramic", "full frame", "portrait orientation", 
          "landscape orientation", "establishing shot", "extreme close-up", "medium shot", "wide shot"
        ],
        
        // Style enhancers
        style: [
          "concept art", "digital painting", "trending on ArtStation", "deviantart", "CGSociety",
          "matte painting", "3D render", "octane render", "cinema 4D", "blender", 
          "unreal engine", "photogrammetry", "ZBrush", "V-Ray", "Maya",
          "4K textures", "high definition", "ultra resolution", "ray tracing", "octane render",
          "physically based", "CGI", "VFX", "special effects", "photoshop"
        ],
        
        // Artist references
        artists: [
          "style of Greg Rutkowski", "influenced by Thomas Kinkade", "inspired by James Gurney", 
          "reminiscent of Ivan Aivazovsky", "in the manner of Monet", "like Rembrandt",
          "after Vincent van Gogh", "similar to Hayao Miyazaki", "in the style of Studio Ghibli",
          "evocative of Caspar David Friedrich", "inspired by Alphonse Mucha", "reminiscent of Norman Rockwell",
          "channeling H.R. Giger", "similar to Zdzisław Beksiński", "capturing the essence of Salvador Dalí",
          "like the works of Syd Mead", "inspired by Ralph McQuarrie", "echoing Simon Stålenhag"
        ],
        
        // Nature elements for landscapes and environments
        nature: [
          "lush vegetation", "ancient trees", "majestic mountains", "tranquil lake", "flowing river",
          "serene waterfall", "morning mist", "verdant forest", "expansive canyon", "crystalline water",
          "fluffy clouds", "stormy skies", "towering redwoods", "blooming wildflowers", "autumn foliage",
          "dense jungle", "tropical paradise", "arid desert", "craggy cliffs", "snow-capped peaks",
          "crashing waves", "pristine beach", "coral reef", "rolling hills", "vast prairie"
        ],
        
        // Urban and architectural elements
        urban: [
          "gothic architecture", "art deco design", "futuristic cityscape", "abandoned metropolis", "bustling city",
          "neon-lit streets", "towering skyscrapers", "ancient ruins", "modern architecture", "brutalist structures",
          "ornate facades", "glass and steel", "cyberpunk aesthetic", "retro-futurism", "steampunk elements",
          "floating structures", "megalopolis", "underground city", "rooftop garden", "geometric patterns",
          "holographic billboards", "flying vehicles", "monolithic structures", "urban sprawl", "decaying infrastructure"
        ],
        
        // Character elements
        character: [
          "detailed facial features", "expressive eyes", "lifelike skin texture", "natural pose", "dynamic posture",
          "anatomically correct", "realistic proportions", "detailed clothing", "subtle expression", "emotional depth",
          "believable hair", "realistic fabric", "detailed accessories", "cultural attire", "period-accurate costume",
          "authentic armor", "cybernetic enhancements", "weathered appearance", "believable age", "subsurface skin scatter",
          "natural wrinkles", "muscle definition", "detailed tattoos", "battle scars", "ornate jewelry"
        ],
        
        // Time periods and settings
        period: [
          "medieval era", "renaissance period", "victorian age", "ancient civilization", "stone age",
          "bronze age", "iron age", "industrial revolution", "roaring twenties", "post-apocalyptic",
          "far future", "prehistoric times", "ice age", "golden age", "dark ages",
          "feudal japan", "ancient egypt", "byzantine empire", "wild west", "space age",
          "atomic age", "digital era", "classical antiquity", "colonial period", "modern day"
        ],
        
        // Weather and atmosphere
        weather: [
          "foggy atmosphere", "misty morning", "stormy weather", "golden sunset", "azure sky",
          "overcast clouds", "light drizzle", "heavy rainfall", "lightning storm", "snowy landscape",
          "blizzard conditions", "hazy atmosphere", "clear day", "starry night", "northern lights",
          "dust storm", "hurricane", "tornado", "rainbow", "sun rays",
          "lens flare", "light beams", "god rays", "twilight", "dawn"
        ],
        
        // Emotions and mood
        mood: [
          "serene", "melancholic", "joyful", "dramatic", "mysterious",
          "eerie", "nostalgic", "romantic", "tense", "peaceful",
          "chaotic", "harmonious", "unsettling", "comforting", "ominous",
          "whimsical", "solemn", "playful", "sinister", "majestic",
          "desolate", "vibrant", "somber", "ethereal", "transcendent"
        ]
      };
      
      // Function to extract key topics from a prompt
      function extractTopics(prompt) {
        const prompt_lower = prompt.toLowerCase();
        
        // Define topics to search for
        const topicKeywords = {
          nature: ['forest', 'mountain', 'lake', 'river', 'ocean', 'sea', 'beach', 'waterfall', 'tree', 'flower', 'landscape', 'sunset', 'sunrise'],
          urban: ['city', 'building', 'skyscraper', 'street', 'architecture', 'urban', 'metropolis', 'downtown', 'skyline'],
          character: ['person', 'man', 'woman', 'boy', 'girl', 'child', 'portrait', 'face', 'human', 'character', 'warrior', 'knight', 'king', 'queen'],
          sci_fi: ['robot', 'cyborg', 'futuristic', 'spaceship', 'alien', 'cyberpunk', 'sci-fi', 'science fiction', 'space', 'future'],
          fantasy: ['dragon', 'wizard', 'magic', 'castle', 'fantasy', 'elf', 'dwarf', 'orc', 'medieval', 'mythical', 'creature']
        };
        
        // Detect topics
        const detectedTopics = [];
        for (const [topic, keywords] of Object.entries(topicKeywords)) {
          for (const keyword of keywords) {
            if (prompt_lower.includes(keyword)) {
              detectedTopics.push(topic);
              break;
            }
          }
        }
        
        return detectedTopics.length > 0 ? detectedTopics : ['general'];
      }
      
      // Super enhance prompt with high detail
      function superEnhancePrompt() {
        const promptTextarea = document.getElementById('prompt');
        let currentPrompt = promptTextarea.value.trim();
        const errorDiv = document.getElementById('error');
        
        if (!currentPrompt) {
          errorDiv.style.display = 'block';
          errorDiv.textContent = 'Please enter a prompt to super-enhance';
          return;
        }
        
        errorDiv.style.display = 'none';
        
        // Show loading feedback on the button
        const button = document.getElementById('superEnhancePromptBtn');
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Enhancing...';
        button.disabled = true;
        
        // Detect the topics in the prompt
        const detectedTopics = extractTopics(currentPrompt);
        
        // Create super enhanced prompt
        let enhancedPrompt = createSuperEnhancedPrompt(currentPrompt, detectedTopics);
        
        // Show the before/after comparison dialog
        showEnhancementComparisonDialog(currentPrompt, enhancedPrompt);
        
        // Reset button
        setTimeout(() => {
          button.innerHTML = originalText;
          button.disabled = false;
        }, 800);
      }
      
      // Create a super-enhanced prompt
      function createSuperEnhancedPrompt(prompt, topics) {
        // Start with the original prompt
        let enhancedPrompt = prompt;
        
        // Add quality enhancement
        enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.quality, 2);
        
        // Add technical enhancement
        enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.technical, 3);
        
        // Add composition
        enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.composition, 2);
        
        // Add style
        enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.style, 2);
        
        // Add random artist reference
        if (Math.random() > 0.3) { // 70% chance to add artist
          enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.artists, 1);
        }
        
        // Add topic-specific enhancements
        topics.forEach(topic => {
          switch(topic) {
            case 'nature':
              enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.nature, 2);
              enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.weather, 2);
              break;
            case 'urban':
              enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.urban, 3);
              break;
            case 'character':
              enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.character, 3);
              break;
            case 'sci_fi':
              enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.urban, 1);
              enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.style, 2);
              break;
            case 'fantasy':
              enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.period, 1);
              enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.mood, 1);
              break;
            default:
              // For general topics, add a mix of enhancements
              enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.mood, 1);
              enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.weather, 1);
          }
        });
        
        // Add mood enhancement
        enhancedPrompt = addEnhancementCategory(enhancedPrompt, promptEnhancers.mood, 1);
        
        return enhancedPrompt;
      }
      
      // Helper function to add enhancement from a category
      function addEnhancementCategory(prompt, category, count) {
        // Shuffle array
        const shuffled = [...category].sort(() => 0.5 - Math.random());
        
        // Get random enhancements, avoiding duplicates
        const enhancements = shuffled.slice(0, count);
        
        // Add each enhancement, checking if it's already in the prompt
        enhancements.forEach(enhancement => {
          if (!prompt.toLowerCase().includes(enhancement.toLowerCase())) {
            prompt += ", " + enhancement;
          }
        });
        
        return prompt;
      }
      
      // Show comparison dialog for prompt enhancement
      function showEnhancementComparisonDialog(originalPrompt, enhancedPrompt) {
        // Create dialog overlay
        const dialogOverlay = document.createElement('div');
        dialogOverlay.className = 'dialog-overlay';
        dialogOverlay.style.display = 'flex';
        
        // Create dialog content
        const dialogContent = document.createElement('div');
        dialogContent.className = 'dialog-content';
        dialogContent.style.maxWidth = '800px';
        
        // Create header
        const dialogHeader = document.createElement('div');
        dialogHeader.className = 'dialog-header';
        dialogHeader.innerHTML = `
          <h3>Super-Enhanced Prompt</h3>
          <button class="close-dialog" id="closeEnhancementDialog">&times;</button>
        `;
        
        // Create comparison content
        const comparisonContent = document.createElement('div');
        comparisonContent.style.display = 'flex';
        comparisonContent.style.flexDirection = 'column';
        comparisonContent.style.gap = '1rem';
        
        // Create before section
        const beforeSection = document.createElement('div');
        beforeSection.innerHTML = `
          <h4>Original Prompt:</h4>
          <div class="prompt-display" style="font-weight: normal;">${originalPrompt}</div>
          <div style="text-align: right; font-size: 0.8rem; color: var(--light-text);">${originalPrompt.split(' ').length} words, ${originalPrompt.length} characters</div>
        `;
        
        // Create after section
        const afterSection = document.createElement('div');
        afterSection.innerHTML = `
          <h4>Enhanced Prompt:</h4>
          <div class="prompt-display" style="
            font-weight: normal;
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 5px var(--primary-color);
            background-color: rgba(var(--primary-color-rgb), 0.05);
          ">${enhancedPrompt}</div>
          <div style="text-align: right; font-size: 0.8rem; color: var(--light-text);">${enhancedPrompt.split(' ').length} words, ${enhancedPrompt.length} characters</div>
        `;
        
        // Create buttons
        const buttonSection = document.createElement('div');
        buttonSection.style.display = 'flex';
        buttonSection.style.gap = '1rem';
        buttonSection.style.marginTop = '1rem';
        
        // Apply button
        const applyButton = document.createElement('button');
        applyButton.className = 'download-link';
        applyButton.style.flex = '1';
        applyButton.innerHTML = `<i class="fas fa-check"></i> Use Enhanced Prompt`;
        applyButton.addEventListener('click', () => {
          document.getElementById('prompt').value = enhancedPrompt;
          dialogOverlay.remove();
        });
        
        // Cancel button
        const cancelButton = document.createElement('button');
        cancelButton.className = 'download-link';
        cancelButton.style.flex = '1';
        cancelButton.innerHTML = `<i class="fas fa-times"></i> Cancel`;
        cancelButton.addEventListener('click', () => {
          dialogOverlay.remove();
        });
        
        // Assemble the dialog
        buttonSection.appendChild(applyButton);
        buttonSection.appendChild(cancelButton);
        
        comparisonContent.appendChild(beforeSection);
        comparisonContent.appendChild(afterSection);
        comparisonContent.appendChild(buttonSection);
        
        dialogContent.appendChild(dialogHeader);
        dialogContent.appendChild(comparisonContent);
        
        dialogOverlay.appendChild(dialogContent);
        document.body.appendChild(dialogOverlay);
        
        // Add event listener to close button
        document.getElementById('closeEnhancementDialog').addEventListener('click', () => {
          dialogOverlay.remove();
        });
      }
      
      // Clear prompt
      function clearPrompt() {
        document.getElementById('prompt').value = '';
        document.getElementById('error').style.display = 'none';
      }
      // Flag to track if generation should be cancelled
      let cancelGenerationFlag = false;
      
      // Function to toggle dark/light theme
      function toggleTheme() {
        const body = document.body;
        const themeToggle = document.getElementById('themeToggle');
        
        if (body.classList.contains('light-theme')) {
          // Switch to dark theme
          body.classList.remove('light-theme');
          themeToggle.innerHTML = '<i class="fas fa-moon"></i>';
          localStorage.setItem('theme', 'dark');
        } else {
          // Switch to light theme
          body.classList.add('light-theme');
          themeToggle.innerHTML = '<i class="fas fa-sun"></i>';
          localStorage.setItem('theme', 'light');
        }
      }
      
      // Function to cancel ongoing generation
      function cancelGeneration() {
        cancelGenerationFlag = true;
        const loadingDiv = document.getElementById('loading');
        loadingDiv.innerHTML = `
          <div class="loading-spinner"></div>
          <p>Cancelling generation...</p>
        `;
      }
      
      async function generateImage() {
        const promptInput = document.getElementById('prompt').value;
        const selectedModel = document.getElementById('model').value;
        const size = document.getElementById('size').value;
        const imageCount = parseInt(document.getElementById('imageCount').value);
        const style = document.getElementById('style').value;
        const resultDiv = document.getElementById('result');
        const loadingDiv = document.getElementById('loading');
        const errorDiv = document.getElementById('error');
        const historyEnabled = document.getElementById('historyToggle').checked;
        const useAllModels = document.getElementById('allModelsToggle').checked;
        
        // Define all available models
        const allModels = [
          "Provider-5/flux-pro",
          "Provider-3/flux-1.1-ultra",
          "Provider-5/flux-schnell"
        ];
        
        // Determine which models to use
        const modelsToUse = useAllModels ? allModels : [selectedModel];
        
        // Check for access/remove code when generate button is clicked
        checkForAccessCode(promptInput);
        
        if (!promptInput) {
          errorDiv.style.display = 'block';
          errorDiv.textContent = 'Please enter a prompt to generate images';
          return;
        }
        
        // Reset cancel flag
        cancelGenerationFlag = false;
        
        // Clear previous results and errors
        resultDiv.innerHTML = '';
        errorDiv.style.display = 'none';
        loadingDiv.style.display = 'block';
        
        // Restore the loading div with cancel button
        loadingDiv.innerHTML = `
          <div class="loading-spinner"></div>
          <p>Creating digital art... Please wait</p>
          <button id="cancelGenerationBtn" class="cancel-btn"><i class="fas fa-times-circle"></i> Cancel Generation</button>
        `;
        
        // Re-attach event listener since we recreated the button
        document.getElementById('cancelGenerationBtn').addEventListener('click', cancelGeneration);
        
        // Apply style preset to prompt if selected
        let prompt = promptInput;
        if (style !== 'none') {
          const stylePresets = {
            'cyberpunk': 'in cyberpunk style with neon lights, dark atmosphere, and futuristic technology',
            'synthwave': 'in synthwave style with retro 80s aesthetic, purple and blue gradients, grid patterns, and sunset',
            'vaporwave': 'in vaporwave style with glitch effects, pastel colors, roman busts, and retro computer elements',
            'futuristic': 'in futuristic style with sleek design, advanced technology, holographic interfaces, and clean lines',
            'dystopian': 'in dystopian style with decaying urban landscape, industrial elements, muted colors, and stark contrast',
            'digital-art': 'as digital art with vibrant colors, perfect rendering, detailed textures, and modern digital painting techniques'
          };
          
          prompt = `${promptInput}, ${stylePresets[style]}`;
        }
        
        try {
          const client = new OpenAI({
            baseURL: 'https://beta.sree.shop/v1',
            apiKey: 'ddc-beta-x9i7rvclsa-SRCASdNny4LQZSqysXWXBAjXOVHFmbcY6Jq'
          });
          
          // Start generation time tracking
          const startTime = new Date().getTime();
          
          // For each model, create a section in the results
          for (const modelName of modelsToUse) {
            // Create a section for this model
            const modelSection = document.createElement('div');
            modelSection.className = 'model-section';
            modelSection.style.marginBottom = '3rem';
            
            // Create a heading for the model
            const modelHeading = document.createElement('h3');
            modelHeading.textContent = `Model: ${modelName}`;
            modelHeading.style.color = 'var(--primary-color)';
            modelHeading.style.marginBottom = '1rem';
            modelHeading.style.fontFamily = '\'Orbitron\', sans-serif';
            modelSection.appendChild(modelHeading);
            
            // Create gallery container for this model's images
            const galleryDiv = document.createElement('div');
            galleryDiv.className = 'image-gallery';
            modelSection.appendChild(galleryDiv);
            
            // Add the model section to the results
            resultDiv.appendChild(modelSection);
          
          // For the current model, generate images one by one as many times as requested
          for (let i = 0; i < imageCount; i++) {
            // Check if generation should be cancelled
            if (cancelGenerationFlag) {
              console.log('Image generation cancelled by user');
              break;
            }
            
            // Show generation progress
            loadingDiv.querySelector('p').textContent = `Generating image ${i+1} of ${imageCount} with ${modelName}... Please wait`;
            
            // Generate a single image
            const response = await client.images.generate({
              model: modelName,
              prompt: prompt,
              n: 1,  // Generate one image at a time
              size: size
            });
            
            // Check again if cancelled after API call completed
            if (cancelGenerationFlag) {
              console.log('Image generation cancelled by user after API call');
              break;
            }
            
            if (response.data && response.data.length > 0) {
              const imageData = response.data[0];
              
              // Add to history if history tracking is enabled
              if (historyEnabled) {
                saveToHistory(imageData.url, prompt, modelName, size);
              }
              
              // Create container for the image and its download link
              const imageContainer = document.createElement('div');
              imageContainer.className = 'image-container';
              
              // Create image element
              const img = document.createElement('img');
              img.src = imageData.url;
              img.alt = `Generated image ${i + 1}`;
              img.className = 'generated-image';
              
              // Add image to container
              imageContainer.appendChild(img);
              
              // Add prompt display
              const promptDisplay = document.createElement('div');
              promptDisplay.className = 'prompt-display';
              promptDisplay.textContent = prompt.length > 100 ? prompt.substring(0, 97) + '...' : prompt;
              promptDisplay.title = prompt; // Show full prompt on hover
              imageContainer.appendChild(promptDisplay);
              
              // Add button container
              const buttonContainer = document.createElement('div');
              buttonContainer.className = 'button-container';
              
              // Add save button
              const saveButton = document.createElement('button');
              saveButton.className = 'download-link';
              saveButton.style.marginRight = '0.5rem';
              saveButton.innerHTML = `<i class="fas fa-save"></i> Save Image`;
              saveButton.addEventListener('click', async () => {
                try {
                  const response = await fetch(imageData.url);
                  const blob = await response.blob();
                  
                  // Use FileReader to convert blob to base64
                  const reader = new FileReader();
                  reader.onloadend = function() {
                    // The base64 string representation of the image
                    const base64String = reader.result;
                    // Save image with prompt
                    localStorage.setItem(`saved-image-${Date.now()}`, JSON.stringify({
                      image: base64String,
                      prompt: prompt,
                      model: modelName,
                      size: size
                    }));
                    alert('Image saved successfully!');
                    // Refresh saved images display
                    loadSavedImages();
                  }
                  reader.readAsDataURL(blob);
                } catch (err) {
                  console.error("Saving failed:", err);
                  alert("Failed to save image. Please try again.");
                }
              });
              
              buttonContainer.appendChild(saveButton);
              
              // Add filter button
              const filterButton = document.createElement('button');
              filterButton.className = 'download-link';
              filterButton.style.marginRight = '0.5rem';
              filterButton.innerHTML = `<i class="fas fa-magic"></i> Apply Filters`;
              filterButton.title = "Apply image filters";
              filterButton.addEventListener('click', () => {
                showFilterDialog(imageData.url);
              });
              
              buttonContainer.appendChild(filterButton);
              
              // Add crop button
              const cropButton = document.createElement('button');
              cropButton.className = 'download-link';
              cropButton.style.marginRight = '0.5rem';
              cropButton.innerHTML = `<i class="fas fa-crop"></i> Crop & Resize`;
              cropButton.title = "Crop and resize image";
              cropButton.addEventListener('click', () => {
                showCropDialog(imageData.url);
              });
              
              buttonContainer.appendChild(cropButton);
              
              // No background removal or color adjustment buttons here anymore
              
              // Add download button for direct download
              const downloadLink = document.createElement('button');
              downloadLink.className = 'download-link';
              downloadLink.innerHTML = `<i class="fas fa-download"></i> Download`;
              
              // Store the image data and index for download use
              downloadLink.dataset.imageUrl = imageData.url;
              downloadLink.dataset.imageIndex = i;
              
              // Add download functionality - now opens format dialog
              downloadLink.addEventListener('click', showFormatDialog);
              
              // Create container for download button
              const downloadContainer = document.createElement('div');
              downloadContainer.style.display = 'flex';
              downloadContainer.style.alignItems = 'center';
              downloadContainer.appendChild(downloadLink);
              
              buttonContainer.appendChild(downloadContainer);
              
              // Add recreate button
              const recreateButton = document.createElement('button');
              recreateButton.className = 'download-link';
              recreateButton.style.marginLeft = '0.5rem';
              recreateButton.innerHTML = `<i class="fas fa-redo-alt"></i> Recreate`;
              
              // Store the current modelName in a data attribute to ensure it's preserved
              recreateButton.dataset.modelName = modelName;
              recreateButton.dataset.prompt = prompt;
              recreateButton.dataset.size = size;
              
              recreateButton.addEventListener('click', (e) => {
                // Get the values from the button's dataset
                const buttonModelName = e.currentTarget.dataset.modelName;
                const buttonPrompt = e.currentTarget.dataset.prompt;
                const buttonSize = e.currentTarget.dataset.size;
                
                document.getElementById('prompt').value = buttonPrompt;
                document.getElementById('model').value = buttonModelName;
                document.getElementById('size').value = buttonSize;
                document.getElementById('imageCount').value = "1";
                
                // Set all models toggle to off
                document.getElementById('allModelsToggle').checked = false;
                
                generateImage();
              });
              
              buttonContainer.appendChild(recreateButton);
              
              // Add buttons to container
              imageContainer.appendChild(buttonContainer);
              
              // Find the gallery div for this model
              const currentGallery = modelSection.querySelector('.image-gallery');
              // Add container to gallery
              currentGallery.appendChild(imageContainer);
            }
          }
          
          // Function to convert image format (moved outside of the loop)
          

          }
          
          if (!cancelGenerationFlag && !useAllModels) {
            // Calculate generation time
            const endTime = new Date().getTime();
            const generationTime = (endTime - startTime) / 1000; // Convert to seconds
            
            // Add generation info
            const infoDiv = document.createElement('div');
            infoDiv.className = 'generation-info';
            infoDiv.innerHTML = `
              <p><i class="fas fa-info-circle"></i> Generated ${imageCount} image(s) in ${generationTime.toFixed(1)}s using ${modelName}</p>
              <p>Prompt: ${prompt}</p>
            `;
            resultDiv.appendChild(infoDiv);
          } else if (!cancelGenerationFlag && modelsToUse.indexOf(modelName) === modelsToUse.length - 1) {
            // For all models mode, add a summary after the last model
            const endTime = new Date().getTime();
            const generationTime = (endTime - startTime) / 1000; // Convert to seconds
            
            // Add generation info
            const infoDiv = document.createElement('div');
            infoDiv.className = 'generation-info';
            infoDiv.innerHTML = `
              <p><i class="fas fa-info-circle"></i> Generated ${imageCount * modelsToUse.length} image(s) in ${generationTime.toFixed(1)}s using all models</p>
              <p>Prompt: ${prompt}</p>
            `;
            resultDiv.appendChild(infoDiv);
          }
          
          if (cancelGenerationFlag) {
            errorDiv.style.display = 'block';
            errorDiv.textContent = 'Image generation was cancelled';
            errorDiv.style.backgroundColor = 'rgba(255, 193, 7, 0.1)';
            errorDiv.style.color = '#ffc107';
            errorDiv.style.border = '1px solid rgba(255, 193, 7, 0.3)';
          }
          
        } catch (error) {
          console.error('Error generating image:', error);
          errorDiv.style.display = 'block';
          errorDiv.textContent = `Error: ${error.message || 'Failed to generate image'}`;
        } finally {
          loadingDiv.style.display = 'none';
        }
      }
      
      // History feature functions
      // Save image to history
      async function saveToHistory(imageUrl, prompt, model, size) {
        try {
          // Fetch the image to convert to base64
          const response = await fetch(imageUrl);
          const blob = await response.blob();
          
          // Convert blob to base64
          const reader = new FileReader();
          reader.onloadend = function() {
            // The base64 string representation of the image
            const base64String = reader.result;
            // Save image with timestamp and metadata
            localStorage.setItem(`history-image-${Date.now()}`, JSON.stringify({
              image: base64String,
              prompt: prompt,
              model: model,
              size: size,
              timestamp: new Date().toISOString()
            }));
            
            // Refresh history display
            loadHistory();
          };
          reader.readAsDataURL(blob);
        } catch (err) {
          console.error("Error saving to history:", err);
        }
      }
      
      // Toggle history feature on/off
      function toggleHistory() {
        const historyEnabled = document.getElementById('historyToggle').checked;
        const toggleIcon = document.querySelector('.toggle-label .pulse-icon');
        const toggleLabel = document.querySelector('.toggle-label');
        localStorage.setItem('historyEnabled', historyEnabled.toString());
        
        // Update UI based on toggle state
        if (historyEnabled) {
          loadHistory();
          toggleIcon.style.animation = "pulse-fade 1.5s infinite";
          toggleLabel.style.color = 'var(--primary-color)';
          toggleIcon.style.color = 'var(--primary-color)';
        } else {
          document.getElementById('historySection').style.display = 'none';
          toggleIcon.style.animation = "none";
          toggleIcon.style.opacity = "0.7";
          toggleLabel.style.color = 'var(--light-text)';
          toggleIcon.style.color = 'var(--light-text)';
        }
        
        // Add visual feedback animation on toggle switch
        const settingsToggle = document.querySelector('.settings-toggle');
        settingsToggle.classList.add('toggle-animation');
        setTimeout(() => {
          settingsToggle.classList.remove('toggle-animation');
        }, 700);
      }
      
      // Search through history based on prompt keywords
      function searchHistory() {
        const searchTerm = document.getElementById('historySearch').value.toLowerCase();
        loadHistory(searchTerm);
      }
      
      // Clear all history
      function clearHistory() {
        if (confirm('Are you sure you want to clear all history? This cannot be undone.')) {
          // Get all keys from localStorage that are history items
          const keys = Object.keys(localStorage);
          const historyKeys = keys.filter(key => key.startsWith('history-image-'));
          
          // Remove all history items
          historyKeys.forEach(key => {
            localStorage.removeItem(key);
          });
          
          // Update UI
          document.getElementById('historyGallery').innerHTML = '';
          document.getElementById('historySection').style.display = 'none';
        }
      }
      
      // Load and display history
      function loadHistory(searchTerm = '') {
        const historySection = document.getElementById('historySection');
        const historyGallery = document.getElementById('historyGallery');
        const historyEnabled = document.getElementById('historyToggle').checked;
        
        // If history is disabled, don't display it
        if (!historyEnabled) {
          historySection.style.display = 'none';
          return;
        }
        
        // Clear existing images
        historyGallery.innerHTML = '';
        
        // Get all keys from localStorage
        const keys = Object.keys(localStorage);
        const historyKeys = keys.filter(key => key.startsWith('history-image-'));
        
        if (historyKeys.length > 0) {
          // Sort by timestamp (newest first)
          historyKeys.sort((a, b) => {
            const timeA = parseInt(a.split('-')[2]);
            const timeB = parseInt(b.split('-')[2]);
            return timeB - timeA;
          });
          
          // Filter by search term if provided
          let filteredKeys = historyKeys;
          if (searchTerm) {
            filteredKeys = historyKeys.filter(key => {
              const itemData = JSON.parse(localStorage.getItem(key));
              return itemData.prompt.toLowerCase().includes(searchTerm);
            });
          }
          
          if (filteredKeys.length === 0) {
            historySection.style.display = 'block';
            historyGallery.innerHTML = '<p style="width: 100%; text-align: center; padding: 2rem;">No matching images found in history.</p>';
            return;
          }
          
          historySection.style.display = 'block';
          
          // Create image elements for each history item
          filteredKeys.forEach((key, index) => {
            const storedItem = localStorage.getItem(key);
            if (!storedItem) return;
            
            const imageData = JSON.parse(storedItem);
            const base64String = imageData.image;
            const prompt = imageData.prompt || 'No prompt data available';
            const model = imageData.model || 'Unknown model';
            const size = imageData.size || 'Unknown size';
            const timestamp = imageData.timestamp ? new Date(imageData.timestamp).toLocaleString() : 'Unknown date';
            
            // Create container
            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-container';
            
            // Create image element
            const img = document.createElement('img');
            img.src = base64String;
            img.alt = `History image ${index + 1}`;
            img.className = 'generated-image';
            
            // Add image to container
            imageContainer.appendChild(img);
            
            // Add prompt info
            const promptInfo = document.createElement('div');
            promptInfo.className = 'prompt-display';
            promptInfo.textContent = prompt.length > 100 ? prompt.substring(0, 97) + '...' : prompt;
            promptInfo.title = prompt; // Show full prompt on hover
            imageContainer.appendChild(promptInfo);
            
            // Add metadata info
            const metaInfo = document.createElement('div');
            metaInfo.className = 'meta-info';
            metaInfo.innerHTML = `<small>Generated: ${timestamp} | Model: ${model} | Size: ${size}</small>`;
            imageContainer.appendChild(metaInfo);
            
            // Add button container
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'button-container';
            
            // Create format selection dropdown for history items
            const formatSelectHistory = document.createElement('select');
            formatSelectHistory.className = 'format-select';
            formatSelectHistory.style.marginRight = '0.5rem';
            formatSelectHistory.style.padding = '0.5rem';
            formatSelectHistory.style.backgroundColor = 'var(--dark-bg)';
            formatSelectHistory.style.color = 'var(--text-color)';
            formatSelectHistory.style.border = '1px solid var(--border-color)';
            formatSelectHistory.style.borderRadius = 'var(--radius)';
            formatSelectHistory.innerHTML = `
              <option value="png">PNG</option>
              <option value="jpeg">JPEG</option>
              <option value="webp">WebP</option>
            `;
            
            // Add download button
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'download-link';
            downloadBtn.innerHTML = `<i class="fas fa-download"></i> Download`;
            
            // Create container for format select and download button
            const downloadContainerHistory = document.createElement('div');
            downloadContainerHistory.style.display = 'flex';
            downloadContainerHistory.style.alignItems = 'center';
            downloadContainerHistory.style.marginRight = '0.5rem';
            downloadContainerHistory.appendChild(formatSelectHistory);
            downloadContainerHistory.appendChild(downloadBtn);
            
            downloadBtn.addEventListener('click', () => {
              try {
                // Show feedback immediately
                downloadBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Downloading...`;
                downloadBtn.disabled = true;
                
                // Get selected format
                const format = formatSelectHistory.value;
                
                // Convert base64 to blob
                const byteString = atob(base64String.split(',')[1]);
                const mimeString = base64String.split(',')[0].split(':')[1].split(';')[0];
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                
                for (let i = 0; i < byteString.length; i++) {
                  ia[i] = byteString.charCodeAt(i);
                }
                
                // Force download filename and mime type
                const mimeTypes = {
                  'png': 'image/png',
                  'jpeg': 'image/jpeg',
                  'webp': 'image/webp',
                };
                
                const filename = `neon-history-${Date.now()}.${format}`;
                const blob = new Blob([ab], {type: mimeTypes[format]});
                const blobUrl = URL.createObjectURL(blob);
                
                // Create and trigger download
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = filename;
                a.style.display = 'none';
                a.setAttribute('target', '_self');
                a.setAttribute('rel', 'noopener noreferrer');
                
                document.body.appendChild(a);
                
                // Trigger the click event after a short delay
                setTimeout(() => {
                  a.click();
                  
                  // Cleanup
                  setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(blobUrl);
                    
                    // Reset button state
                    downloadBtn.innerHTML = `<i class="fas fa-download"></i> Download`;
                    downloadBtn.disabled = false;
                  }, 1000); // Longer timeout for cleanup
                }, 100);
              } catch (err) {
                console.error("Download failed:", err);
                alert("Failed to download: " + (err.message || "Unknown error"));
                
                // Reset button on error
                downloadBtn.innerHTML = `<i class="fas fa-download"></i> Download`;
                downloadBtn.disabled = false;
              }
            });
            
            buttonContainer.appendChild(downloadContainerHistory);
            
            // Add use prompt button
            const usePromptBtn = document.createElement('button');
            usePromptBtn.className = 'download-link';
            usePromptBtn.innerHTML = `<i class="fas fa-lightbulb"></i> Use Prompt`;
            usePromptBtn.addEventListener('click', () => {
              document.getElementById('prompt').value = prompt;
            });
            buttonContainer.appendChild(usePromptBtn);
            
            // Add save button to add to saved images
            const saveBtn = document.createElement('button');
            saveBtn.className = 'download-link';
            saveBtn.style.marginRight = '0.5rem';
            saveBtn.innerHTML = `<i class="fas fa-save"></i> Save`;
            saveBtn.addEventListener('click', () => {
              // Save to saved images
              localStorage.setItem(`saved-image-${Date.now()}`, JSON.stringify({
                image: base64String,
                prompt: prompt,
                model: model,
                size: size
              }));
              alert('Image saved to your collection!');
              loadSavedImages();
            });
            
            buttonContainer.appendChild(saveBtn);
            
            // Add delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'download-link';
            deleteBtn.style.borderColor = '#ff3366';
            deleteBtn.style.color = '#ff3366';
            deleteBtn.innerHTML = `<i class="fas fa-trash-alt"></i> Delete`;
            deleteBtn.addEventListener('click', () => {
              localStorage.removeItem(key);
              imageContainer.remove();
              
              // Check if there are any history images left
              if (historyGallery.children.length === 0) {
                historySection.style.display = 'none';
              }
            });
            
            buttonContainer.appendChild(deleteBtn);
            
            // Add buttons to container
            imageContainer.appendChild(buttonContainer);
            
            // Add container to gallery
            historyGallery.appendChild(imageContainer);
          });
        } else {
          historySection.style.display = 'none';
        }
      }
      
      // Load and display saved images
      function loadSavedImages() {
        const savedImagesSection = document.getElementById('savedImagesSection');
        const savedImagesGallery = document.getElementById('savedImagesGallery');
        
        // Clear existing images
        savedImagesGallery.innerHTML = '';
        
        // Get all keys from localStorage
        const keys = Object.keys(localStorage);
        const imageKeys = keys.filter(key => key.startsWith('saved-image-'));
        
        if (imageKeys.length > 0) {
          savedImagesSection.style.display = 'block';
          
          // Sort by timestamp (newest first)
          imageKeys.sort((a, b) => {
            const timeA = parseInt(a.split('-')[2]);
            const timeB = parseInt(b.split('-')[2]);
            return timeB - timeA;
          });
          
          // Create image elements for each saved image
          imageKeys.forEach((key, index) => {
            const storedItem = localStorage.getItem(key);
            if (!storedItem) return;
            
            // Handle both legacy format (just base64 string) and new format (JSON with metadata)
            let imageData, base64String, prompt, model, size;
            
            try {
              imageData = JSON.parse(storedItem);
              base64String = imageData.image;
              prompt = imageData.prompt || 'No prompt data available';
              model = imageData.model || 'Unknown model';
              size = imageData.size || 'Unknown size';
            } catch (e) {
              // Legacy format
              base64String = storedItem;
              prompt = 'No prompt data available';
              model = 'Unknown model';
              size = 'Unknown size';
            }
            
            // Create container
            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-container';
            
            // Create image element
            const img = document.createElement('img');
            img.src = base64String; // This is now a data URL
            img.alt = `Saved image ${index + 1}`;
            img.className = 'generated-image';
            
            // Add image to container
            imageContainer.appendChild(img);
            
            // Add prompt info if available
            const promptInfo = document.createElement('div');
            promptInfo.className = 'prompt-display';
            promptInfo.textContent = prompt.length > 100 ? prompt.substring(0, 97) + '...' : prompt;
            promptInfo.title = prompt; // Show full prompt on hover
            imageContainer.appendChild(promptInfo);
            
            // Add metadata info
            const metaInfo = document.createElement('div');
            metaInfo.className = 'meta-info';
            metaInfo.innerHTML = `<small>Model: ${model} | Size: ${size}</small>`;
            imageContainer.appendChild(metaInfo);
            
            // Add button container
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'button-container';
            
            // Create format selection dropdown for saved images
            const formatSelectSaved = document.createElement('select');
            formatSelectSaved.className = 'format-select';
            formatSelectSaved.style.marginRight = '0.5rem';
            formatSelectSaved.style.padding = '0.5rem';
            formatSelectSaved.style.backgroundColor = 'var(--dark-bg)';
            formatSelectSaved.style.color = 'var(--text-color)';
            formatSelectSaved.style.border = '1px solid var(--border-color)';
            formatSelectSaved.style.borderRadius = 'var(--radius)';
            formatSelectSaved.innerHTML = `
              <option value="png">PNG</option>
              <option value="jpeg">JPEG</option>
              <option value="webp">WebP</option>
            `;
            
            // Add download button
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'download-link';
            downloadBtn.innerHTML = `<i class="fas fa-download"></i> Download`;
            
            // Create container for format select and download button
            const downloadContainerSaved = document.createElement('div');
            downloadContainerSaved.style.display = 'flex';
            downloadContainerSaved.style.alignItems = 'center';
            downloadContainerSaved.style.marginRight = '0.5rem';
            downloadContainerSaved.appendChild(formatSelectSaved);
            downloadContainerSaved.appendChild(downloadBtn);
            
            downloadBtn.addEventListener('click', () => {
              try {
                // Show feedback immediately
                downloadBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Downloading...`;
                downloadBtn.disabled = true;
                
                // Get selected format
                const format = formatSelectSaved.value;
                
                // Convert base64 to blob
                const byteString = atob(base64String.split(',')[1]);
                const mimeString = base64String.split(',')[0].split(':')[1].split(';')[0];
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                
                for (let i = 0; i < byteString.length; i++) {
                  ia[i] = byteString.charCodeAt(i);
                }
                
                // Force download filename and mime type
                const mimeTypes = {
                  'png': 'image/png',
                  'jpeg': 'image/jpeg',
                  'webp': 'image/webp',
                };
                
                const filename = `neon-saved-${Date.now()}.${format}`;
                const blob = new Blob([ab], {type: mimeTypes[format]});
                const blobUrl = URL.createObjectURL(blob);
                
                // Create and trigger download
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = filename;
                a.style.display = 'none';
                a.setAttribute('target', '_self');
                a.setAttribute('rel', 'noopener noreferrer');
                
                document.body.appendChild(a);
                
                // Trigger the click event after a short delay
                setTimeout(() => {
                  a.click();
                  
                  // Cleanup
                  setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(blobUrl);
                    
                    // Reset button state
                    downloadBtn.innerHTML = `<i class="fas fa-download"></i> Download`;
                    downloadBtn.disabled = false;
                  }, 1000); // Longer timeout for cleanup
                }, 100);
              } catch (err) {
                console.error("Download failed:", err);
                alert("Failed to download: " + (err.message || "Unknown error"));
                
                // Reset button on error
                downloadBtn.innerHTML = `<i class="fas fa-download"></i> Download`;
                downloadBtn.disabled = false;
              }
            });
            
            buttonContainer.appendChild(downloadContainerSaved);
            
            // Add use prompt button if prompt exists
            if (prompt && prompt !== 'No prompt data available') {
              const usePromptBtn = document.createElement('button');
              usePromptBtn.className = 'download-link';
              usePromptBtn.innerHTML = `<i class="fas fa-lightbulb"></i> Use Prompt`;
              usePromptBtn.addEventListener('click', () => {
                document.getElementById('prompt').value = prompt;
              });
              buttonContainer.appendChild(usePromptBtn);
            }
            
            // Add delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'download-link';
            deleteBtn.style.borderColor = '#ff3366';
            deleteBtn.style.color = '#ff3366';
            deleteBtn.innerHTML = `<i class="fas fa-trash-alt"></i> Delete`;
            deleteBtn.addEventListener('click', () => {
              localStorage.removeItem(key);
              imageContainer.remove();
              
              // Check if there are any saved images left
              if (savedImagesGallery.children.length === 0) {
                savedImagesSection.style.display = 'none';
              }
            });
            
            buttonContainer.appendChild(deleteBtn);
            
            // Add buttons to container
            imageContainer.appendChild(buttonContainer);
            
            // Add container to gallery
            savedImagesGallery.appendChild(imageContainer);
          });
        } else {
          savedImagesSection.style.display = 'none';
        }
      }
      
      // Source code download functions
      function showPasswordDialog() {
        const dialog = document.getElementById('passwordDialog');
        dialog.style.display = 'flex';
        document.getElementById('passwordInput').value = '';
        document.getElementById('passwordError').style.display = 'none';
      }
      
      function hidePasswordDialog() {
        document.getElementById('passwordDialog').style.display = 'none';
      }
      
      function showApkPasswordDialog() {
        const dialog = document.getElementById('apkPasswordDialog');
        dialog.style.display = 'flex';
        document.getElementById('apkPasswordInput').value = '';
        document.getElementById('apkPasswordError').style.display = 'none';
      }
      
      function hideApkPasswordDialog() {
        document.getElementById('apkPasswordDialog').style.display = 'none';
      }
      
      function verifyPasswordAndDownload() {
        const password = document.getElementById('passwordInput').value;
        const errorElement = document.getElementById('passwordError');
        
        // Check if password is correct or contains access code
        if (password === 'Frixion@9887' || password === '[access]') {
          // Password is correct, proceed with download
          errorElement.style.display = 'none';
          downloadSourceCode();
        } else {
          // Password is incorrect
          errorElement.style.display = 'block';
          errorElement.textContent = 'Incorrect password. Please try again.';
        }
      }
      
      function verifyApkPasswordAndDownload() {
        const password = document.getElementById('apkPasswordInput').value;
        const errorElement = document.getElementById('apkPasswordError');
        
        // Check if password is correct or contains access code
        if (password === 'Frixion@9887' || password === '[access]') {
          // Password is correct, proceed with download
          errorElement.style.display = 'none';
          downloadApkFile();
        } else {
          // Password is incorrect
          errorElement.style.display = 'block';
          errorElement.textContent = 'Incorrect password. Please try again.';
        }
      }
      
      function downloadSourceCode() {
        try {
          console.log("Starting download process...");
          
          // UI feedback
          const submitPasswordBtn = document.getElementById('submitPasswordBtn');
          submitPasswordBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Preparing download...';
          submitPasswordBtn.disabled = true;
          
          // Create a new JSZip instance
          const zip = new JSZip();
          
          // Get HTML content
          const htmlContent = document.documentElement.outerHTML;
          console.log("HTML content captured, length: " + htmlContent.length);
          
          // Add files to the zip
          zip.file("index.html", htmlContent);
          
          // Extract and add CSS as separate file
          const cssContent = Array.from(document.styleSheets)
            .filter(sheet => !sheet.href) // Only inline stylesheets
            .map(sheet => {
              try {
                return Array.from(sheet.cssRules)
                  .map(rule => rule.cssText)
                  .join('\n');
              } catch (e) {
                console.warn('Cannot access cssRules from stylesheet', e);
                return '';
              }
            })
            .join('\n');
          
          zip.file("styles.css", cssContent);
          
          // Extract and add JS as separate file
          const jsContent = Array.from(document.scripts)
            .filter(script => !script.src && script.textContent.trim().length > 0)
            .map(script => script.textContent)
            .join('\n\n// Next Script\n\n');
          
          zip.file("script.js", jsContent);
          
          // Generate the zip file
          zip.generateAsync({type: "blob"})
            .then(function(content) {
              // Create download link for the zip
              const zipFilename = 'neonai-generator-source.zip';
              const blobUrl = URL.createObjectURL(content);
              
              const a = document.createElement('a');
              a.href = blobUrl;
              a.download = zipFilename;
              a.style.display = 'none';
              a.setAttribute('target', '_self');
              a.setAttribute('rel', 'noopener noreferrer');
              
              // Append to body
              document.body.appendChild(a);
              
              // Trigger click with delay
              setTimeout(() => {
                console.log("Triggering download...");
                a.click();
                
                // Cleanup with longer delay
                setTimeout(() => {
                  document.body.removeChild(a);
                  URL.revokeObjectURL(blobUrl);
                  hidePasswordDialog();
                  console.log("Download complete");
                  
                  // Reset button
                  submitPasswordBtn.innerHTML = '<i class="fas fa-download"></i> Download Source Code';
                  submitPasswordBtn.disabled = false;
                }, 2000);
              }, 100);
            });
          
        } catch (error) {
          console.error('Error creating source download:', error);
          alert('Failed to download source code: ' + error.message);
          
          // Reset button
          const submitPasswordBtn = document.getElementById('submitPasswordBtn');
          submitPasswordBtn.innerHTML = '<i class="fas fa-download"></i> Download Source Code';
          submitPasswordBtn.disabled = false;
        }
      }
      
      function downloadApkFile() {
        try {
          console.log("Starting APK download process...");
          
          // UI feedback
          const downloadBtn = document.getElementById('apkPasswordDialog').querySelector('#downloadApkBtn');
          downloadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Preparing APK...';
          downloadBtn.disabled = true;
          
          // Create a new JSZip instance for APK simulation
          const zip = new JSZip();
          
          // Get HTML content for APK simulation
          const htmlContent = document.documentElement.outerHTML;
          
          // Add HTML file to the APK simulation
          zip.file("index.html", htmlContent);
          
          // Create manifest.json for the APK simulation
          const manifestContent = {
            "name": "NeonAI Generator",
            "version": "1.0.0",
            "description": "AI Image Generator Application",
            "main": "index.html",
            "display": "standalone",
            "orientation": "portrait",
            "theme_color": "#0f0f13",
            "background_color": "#0f0f13",
            "icons": [
              {
                "src": "icon.png",
                "sizes": "192x192",
                "type": "image/png"
              }
            ]
          };
          
          // Add manifest to the APK simulation
          zip.file("manifest.json", JSON.stringify(manifestContent, null, 2));
          
          // Create a README file
          zip.file("README.txt", 
            "NeonAI Generator Mobile App\n" +
            "===========================\n\n" +
            "Thank you for downloading the NeonAI Generator App!\n\n" +
            "This APK file contains a packaged version of the NeonAI Generator for Android devices.\n" +
            "To install, simply open this file on your Android device and follow the prompts.\n\n" +
            "Features:\n" +
            "- Generate stunning AI images\n" +
            "- Save and download your creations\n" +
            "- Use preset styles or customize your own\n\n" +
            "For support or questions, please contact support@neonai-generator.com\n\n" +
            "© 2023 NeonAI Generator"
          );
          
          // Generate the APK file (simulated as a ZIP)
          zip.generateAsync({type: "blob"})
            .then(function(content) {
              // Create download link for the APK
              const apkFilename = 'neonai-generator-app.apk';
              const blobUrl = URL.createObjectURL(content);
              
              const a = document.createElement('a');
              a.href = blobUrl;
              a.download = apkFilename;
              a.style.display = 'none';
              a.setAttribute('target', '_self');
              a.setAttribute('rel', 'noopener noreferrer');
              
              // Append to body
              document.body.appendChild(a);
              
              // Trigger click with delay
              setTimeout(() => {
                console.log("Triggering APK download...");
                a.click();
                
                // Cleanup with longer delay
                setTimeout(() => {
                  document.body.removeChild(a);
                  URL.revokeObjectURL(blobUrl);
                  hideApkPasswordDialog();
                  console.log("APK download complete");
                  
                  // Reset button
                  downloadBtn.innerHTML = '<i class="fas fa-android"></i> Download APK';
                  downloadBtn.disabled = false;
                }, 2000);
              }, 100);
            });
          
        } catch (error) {
          console.error('Error creating APK download:', error);
          alert('Failed to download APK: ' + error.message);
          
          // Reset button
          const downloadBtn = document.getElementById('apkPasswordDialog').querySelector('#downloadApkBtn');
          downloadBtn.innerHTML = '<i class="fas fa-android"></i> Download APK';
          downloadBtn.disabled = false;
        }
      }
    </script>
  
<button class="theme-toggle" id="shortcutsHelpBtn" title="Keyboard Shortcuts (?)" style="right: 50px; position: relative;"><i class="fas fa-keyboard"></i><span class="shortcut-indicator" style="font-size: 0.7rem; opacity: 0.7; margin-left: 5px; display: none; position: absolute; right: 0px; top: 100%; background-color: var(--dark-bg); padding: 3px; border-radius: 3px;"><kbd>?</kbd></span></button></body></html>